# RabbitMQ

![Untitled](RabbitMQ%20d5324aca84b14539a1d3bd28b55c08b3/Untitled.png)

Queue: Bir iÅŸin, bir kuyruÄŸa alÄ±nmasÄ± ve ana uygulamadan baÄŸÄ±msÄ±z olarak gerÃ§ekleÅŸtirilmesidir. Kuyrukta olan iÅŸler sÄ±rasÄ±yla yapÄ±lÄ±r

Buna en gÃ¼zel Ã¶rnek email gÃ¶nderimidir. Toplu email atma iÅŸlemlerinde gerekli fonksiyonu, her alÄ±cÄ±ya email gÃ¶nderilene kadar bekletmek(Ã¶rneÄŸin 1 milyon kiÅŸi varsa) gereksizdir. Zaman kaybÄ±dÄ±r.

Bunun iÃ§in mesela 1 milyon email bir kuyruÄŸa alÄ±nÄ±r ve ana fonksiyondan baÄŸÄ±msÄ±z olarak sÄ±rasÄ±yla ilgili alÄ±cÄ±lara gÃ¶nderilir.

### KullanÄ±m SenaryolarÄ±

- (Toplu) email gÃ¶nderimi
- Veri iÅŸleme hacminin bulunduÄŸu yerlerde
- DBâ€™den Ã§ekilen verinin cacheâ€™e yazÄ±lmasÄ±nda
- Multipart dosyalarÄ±nÄ±n ilgili serverâ€™lara daÄŸÄ±tÄ±lmasÄ±nda ve compress yapÄ±lmasÄ±nda

### RabbitMQ YapÄ±sÄ±

![Untitled](RabbitMQ%20d5324aca84b14539a1d3bd28b55c08b3/Untitled%201.png)

- Consumer: Ä°ÅŸin iletildiÄŸi sistem. Mesela bir sosyal medya uygulamasÄ±nda, farklÄ± Ã§Ã¶zÃ¼nÃ¼rlÃ¼klerde fotoÄŸrafÄ±n kaydedilmesi iÃ§in ana sistemin bekletilmesi yerine fotoÄŸrafÄ± iÅŸleyecek diÄŸer server
- Publisher: burada iÅŸi atayan yapÄ±dÄ±r. Mesela ana uygulamada email gÃ¶nderiminden sorumlu fonksiyon
- RabbitMQ: BÃ¼tÃ¼n bu kuyruk iÅŸlemini yapan sistem
- Routing key: Bir nevi â€œkeywordâ€. KuyruÄŸa girecek iÅŸlerin kategorisini ayÄ±rmak ve gruplamak iÃ§in kullanÄ±lÄ±r. Mesela â€œemailâ€ keyâ€™i kullanÄ±lÄ±rsa bunun bir email iÅŸi olduÄŸu anlaÅŸÄ±lÄ±r. Ve buna gÃ¶re route eder gerekli kuyruÄŸa.

<aside>
ğŸ’¡ Peki routing keyâ€™e ne gerek var?

RabbitMQ sadece tek bir iÅŸ iÃ§in kullanÄ±lmaz. Mesela hem fotoÄŸraf iÅŸleme iÅŸlemini, hem email gÃ¶nderimini, hem veri iÅŸlemeyiâ€¦ aynÄ± kuyrukta yapabilir. Bu iÅŸlerin karÄ±ÅŸmamasÄ± iÃ§in â€œkeyâ€ler ekler. BÃ¶ylece ilgili consumerâ€™a gÃ¶nderilir. Ä°lla ki bir consumer olmak zorunda deÄŸildir. 10 tane farklÄ± server olarak 10 farklÄ± consumer olabilir. Mesela 2 tanesi email olabilir. Emailler, tek bir serverin sÄ±rayla gÃ¶ndermesindense iki farklÄ± serverâ€™in gÃ¶ndermesi daha hÄ±zlÄ± olur(farklÄ± threadâ€™lerde Ã§alÄ±ÅŸÄ±rlarsa)

</aside>

- Exchange: Bu keyâ€™li iÅŸleri kuyruÄŸa aktarÄ±r.
- Queue: TÃ¼m iÅŸlerin bulunduÄŸu yapÄ±. FarklÄ± kuyruklar olabilir. Her key iÃ§in bir farklÄ± queue
- Channels: Publisherâ€™dan veriler aslÄ±nda excangeâ€™ye channels aracÄ±lÄ±ÄŸÄ±yla gelir. Bu channels iki yÃ¶nlÃ¼ Ã§alÄ±ÅŸÄ±r. Consumer bir iÅŸi iÅŸlediÄŸinde channels aracÄ±lÄ±ÄŸÄ±yla geri bildirim veririr ki publisherin bundan haberi olsun. Golangâ€™daki wg.Done gibi. RabbitMQ da zaten Erlang ile yazÄ±lmÄ±ÅŸ.
- Exchange Types: Ä°ÅŸler kuyruÄŸa aktarÄ±lÄ±rkenki aktarma ÅŸeklidir.
    - Direct Exchange: Ä°lgili keyâ€™leri ilgili kuyruklara direkt aktarÄ±r. Itâ€™s a classic
    - Fanout excange: TÃ¼m iÅŸleri(keye bakmaksÄ±zÄ±n) tÃ¼m kuyruklara aktarÄ±r
    - Topic exhange: Keyâ€™lere gÃ¶re kuyruklara gider ancak keyâ€™lerde wildcardâ€™a gÃ¶re farklÄ± kuyruklara gidebilir.
        
        ![Untitled](RabbitMQ%20d5324aca84b14539a1d3bd28b55c08b3/Untitled%202.png)
        

<aside>
ğŸ’¡ RabbitMQ AMQP kullanÄ±r. Bir protokoldur. Kuyruklama protokÃ¼lÃ¼dÃ¼r.

</aside>

<aside>
ğŸ’¡ EÄŸer consumer, publisherâ€™dan gelen mesajÄ± aldÄ±ktan sonra channel.ack() gondermezse, mesaj sÃ¼rekli olarak kuyrukta bekler ve boÅŸ bulduÄŸu serverâ€™a gitmeye devam eder. EÄŸer ack() gÃ¶nderilirse o mesaj artÄ±k kuyruktan silinir.

</aside>

### Javascript

![Producer](RabbitMQ%20d5324aca84b14539a1d3bd28b55c08b3/Untitled%203.png)

Producer

> Assert queue ile, queueNameâ€™e sahip olan iÅŸlere bakacak bir kuyruk oluÅŸturur.
> 

> Channel.sendToQueue ile de, aslÄ±nda iÅŸe routingKey ekler. BÃ¶ylece kuyruklar onu algÄ±lar
> 

![Consumer](RabbitMQ%20d5324aca84b14539a1d3bd28b55c08b3/Untitled%204.png)

Consumer

> channel.consume ile belli queueNameâ€™e sahip bir kuyruÄŸu dinler.
> 

# DÃ¶kÃ¼mandan Ã–ÄŸrendiklerim

### Exchange And Queue

Exchange: Exchange ile kuyruk farklÄ± ÅŸeylerdir. Ã–rneÄŸin bir mesaj produce edilip exhcangeâ€™e gÃ¶nderilir. Exchange ise bunu kuyruÄŸa gÃ¶nderir. Ã‡ok gÃ¼zeel ama nasÄ±l?

> Ã–rneÄŸin logger adÄ±nda bir exchange vardÄ±r. Ve â€œwarningâ€, â€œerrorâ€, â€œfatalâ€ gibi kuyruklarÄ±mÄ±z vardÄ±r. Ve bu kuyruklar logger exchangeâ€™sine bind olur. Loggerâ€™dan gelen tÃ¼m bilgiler, eÄŸer exchange tipi, â€œfanoutâ€ ise tÃ¼m kuyruklara gÃ¶nderilir(pub-sub). Ama exchange tipi â€œdirectâ€ olduÄŸunda gÃ¶nderilen mesajÄ±n â€œrouting keyâ€i ne ise o routing keyâ€™e sahip kuyruÄŸa gÃ¶nderilir.
> 

### Queue Concepts

- Durability: RabbitMQ server kapandÄ±ÄŸÄ±nda ya da Ã§Ã¶ktÃ¼ÄŸÃ¼nde kuyruÄŸun ve mesajlarÄ±n silinmemesini saÄŸlar.
- Exclusive: RabbitMQâ€™nin ilk Ã§alÄ±ÅŸÄ±nda var olup diÄŸer restartâ€™larÄ±nda silinecek olan queue tipidir.
- Auto ack: Gelen mesaj tÃ¼ketildiÄŸi anda ack() gÃ¶nderilir..
- Persistent: Server yeniden baÅŸladÄ±ÄŸÄ±nda mesajlarÄ±n silinmediÄŸinden emin olmak iÃ§in gÃ¶nderilen mesaja field olarak DeliveryMode: Persistent eklenir

```go
err = ch.PublishWithContext(ctx,
  "",           // exchange
  q.Name,       // routing key
  false,        // mandatory
  false,
  amqp.Publishing {
    DeliveryMode: amqp.Persistent,
    ContentType:  "text/plain",
    Body:         []byte(body),
})
```

- Fair Dispatch: Rabbit, hangi workerâ€™in daha aÄŸÄ±r iÅŸ aldÄ±ÄŸÄ±nÄ± bilmez. Bunun iÃ§in tÃ¼m workerâ€™lara eÅŸit miktarda veri gÃ¶nderielceÄŸini sÃ¶ylÃ¼yoruz. Yani birim zamanda bir tane.

```go
err = ch.Qos(
  1,     // prefetch count
  0,     // prefetch size
  false, // global
)
```

### Topic Exhnange

Topic excange, wildcard saÄŸlar.

![Untitled](RabbitMQ%20d5324aca84b14539a1d3bd28b55c08b3/Untitled%205.png)

Gelen route_keyâ€™lere bakar. Noktalar arasÄ± kategorilere ayrÄ±lÄ±r. Her bir kelime bir kategoridir. Wilcard desteÄŸi verir. Ä°Ã§inde orange geÃ§en, rabbit geÃ§en, lazy geÃ§enleri ayÄ±klar ve sadece onlarÄ± kabul eder. YukarÄ±daki gÃ¶rselde sÄ±rasÄ±yla ÅŸÃ¶yle bir kullanÄ±m vardÄ±r:

1. ÃœÃ§ kelimeden ikinci kelimesi orange olanlarÄ± seÃ§er
2. ÃœÃ§ kelimeden Ã¼Ã§Ã¼ncÃ¼sÃ¼ rabbit olanlarÄ± seÃ§er
3. KaÃ§ kelimeli olursa olsun ilk kelimesi lazy olanlarÄ± seÃ§er

â€œ*â€ iÅŸareti sadece bir kelimenin yerine geÃ§er

â€œ#â€ iÅŸareti birden Ã§ok kelimenin yerine geÃ§ebilir.

EÄŸer bu iki iÅŸaretten biri yoksa, â€œdirect exchangeâ€ olarak davranÄ±r.