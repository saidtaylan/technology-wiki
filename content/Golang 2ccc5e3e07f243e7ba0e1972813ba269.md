# Golang

- Types
    - Golang, tipin çok önemli olduğu bir dildir.
    - Tipsiz sabitler:  Kullanıldığı bağlama göre tip alır. Varsayılan olarak, verilen değerin tipine göre tip alır. Kullanıldığı yerde bir tip type conversion yapılır.
    
    ```go
    const degisken = 10
    fmt.Printf("%T, %v", degisken, degisken)
    // int64, 10
    
    fmt.Printf("%t, Tv", (degisken +3.4), (degisken+3.4))
    // float64, 13.4
    ```
    
    - İşlemler için tiplerin aynı olması gerekir. int64 ve int32 dahi aynı değildir
    - string ve int toplanamaz
    - string direk sayıya ya da sayı direk string’e cast edilemez Bunun için Atoi- itoa kullanılır.
    - Type dönüşümü, adı tipi olan bir fonksiyon ile yapılır
    
    ```go
    degisken := 3.4
    degisken2 := int8(degisken)
    // degisken2 = 3
    ```
    
- Scope
    
    Statik kapsamlı bir dildir. Text bazlı olarak kapsamları tespit eder. JS gibi fonksiyonun çağrıldığı yerdeki ebeveyn fonksiyonun ortamını kullanamaz.
    
- If Else
    - IF statement’ınde atama işlemi yapılabilir ve bu işlem sadece blokta geçerli olacaktır
    
    ```go
    if i:=5; i<10 {
    	// ....
    }
    ```
    
    - Else bloğunun başlangıcı yani else keyword’ü, if ya da else-if bloğunu bitiş süslü parantezi ile aynı satırda olmalıdır yoksa hata verecektir.
    
    ```go
    // Yanlış
    if x>5 {
    	// ...
    }
    else {
    	// ....
    }
    
    // Doğru
    if x>5 {
    	// ...
    } else {
    	// ....
    }
    ```
    
    GO’nun yapısı gereği return değeri olan fonksiyonlarda else’lerden kaçınılmalıdır. IF’in içinde return verilmelidir. If koşulu sağlanmadığında zaten direkt koşul dışına çıkacağı için else bloğuna gerek yoktur. Hatta sadece fonksiyonlarda değil bütün GO dilinde else’lere çok da gerek yoktur🙂
    
    ```go
    // Yanlış
    if num := 10; num % 2 == 0 {
        fmt.Println(num,"is even") 
    }  else {
        fmt.Println(num,"is odd")
    }
    
    // Doğru
    if num := 10; num%2 == 0 {
        fmt.Println(num, "is even")
        return
        }
        fmt.Println(num, "is odd")
    ```
    
- Blank Identifier
    
    Bir değişkeni tanımladık ama kullanmak istemiyoruz. Mesela fonksiyon bir hata değeri return ediyordur ama biz bu değeri kullanmak istemiyoruz. Ancak GO’nun gereği hatayı bir değişkene atamalıyız. İşte burada blank identifier işin içine giriyor. Daha sonra kullanmak istemeeyceğimiz değişenin yerine “_”(alt çzigi) koyuyoruz. 
    
    ```go
    reader := bufio.NewReader(os.Stdin)
    val, _ := reader.ReadString('\n')
    // Read metodundan dönen hatayı bir daha kullanmayacğımız için blank identifier
    // kullandık
    ```
    
- Quotes
    - Single quote: Tek bir karakter ya da sadece bir kaçış karakteri(\n) barındıran ifadelerde kullanılır.
    - Double quote: Bir string veya metni yazmak için kullanılır.
    - Back-tick: Bir string’i yazar. Ancak kaçış ifadelerini de salt string olarak yazar. Örneğin “\t” ifadesini gördüğünde boşluk bırakmak yerine bunu yalnızca “\t” stringi olarak algılayacaktır.
    
    ```go
    variable := '\n'
    myString := "Muhammed Said TAYLAN"
    ```
    
- Functions
    
    ```go
    /*
    	Fonksiyonların parametrelerinin tipleri aynı ise en sağdaki parametreden sonra
    	tip belirtmek yeterlidir. Soldakiler için de aynı tip geçerli olacaktır. veya her 
    	parametre için herbirinin yanına tipi de yazılabilir.
    	Fonksiyonun dönüş tipi, parantezlerin dışına yazılır. İleride görüleceği üzere
    	eğer birden fazla dönüş tipi varsa bunlar da paranteze alınabilir.
    */
    fmt.Println(myFunc(3, 5))
    
    func myFunc(x, y int) int {
    	return x+y
    }
    ```
    
    ```go
    /*
    	Bir fonksiyondan, birden fazla değer dönebilir. Bunun için her dönen değer için
    	tip belirtilmelidir.
    	Return değerlerinin ismi olmak zorunda değildir. Eğer return isminde bir
    	değişken bildirilirse return’de hangi değişkenlerin return edileceğini tekrar
    	belirtmeye gerek yoktur. Aşağıdaki iki kod da geçerlidir.
    */
    
    bolum, kalan := bol(104, 5)
    
    func bol(bolunen, bolen int) (bolum, kalan int) {
    	return bolunen/bolen, bolunen%bolen
    }
    
    // alternative to above
    func bol(bolunen, bolen int) (bolum, kalan int) {
    	bolum := bolunen/bolen
    	kalan := bolunen % bolen
    	return
    }
    
    func bol(bolunen, bolen int) (int, int) {
    	return bolunen/bolen, bolunen%bolen
    }
    ```
    
- Errors
    
    ```go
    /*
    	Hatalar genellikle fonksiyonların son parametresi olara tanımlanır. Diğer dillerin
    	aksine exception olayları yoktur. Bir hata tipi vardır ve bu hata tipinde hata
    	değişkenleri oluşturulur. erros.New() ifadesi ile custom hatalar oluşturulabilir.
    */
    import (
    // ...
    "errors"
    )
    
    func main() {
    	bolum, kalan, err := bol(104, 5)
    	if err != nil {
    		fmt.Print(err)
    	}
    	fmt.Println(bolum, kalan)
    }
    
    func bol(bolunen, bolen int) (bolum, kalan int, err error) {
    	if bolunen <= 0 {
    		return 0, 0, errors.New("fonksiyonumuz gereği negatif sayıları bölemezsiniz :)")
    	}
    	return bolunen / bolen, bolunen % bolen, nil
    }
    
    /*
    	errors.New yerine fmt.Errorf() de kullanılabilir. Printf de olduğu gibi kullanılır
    */
    func main() {
    	bolum, kalan, err := bol(104, 5)
    	if err != nil {
    		fmt.Print(err)
    	}
    	fmt.Println(bolum, kalan)
    }
    
    func bol(bolunen, bolen int) (bolum, kalan int, err error) {
    	if bolunen <= 0 {
    		return 0, 0,
    		fmt.Errorf("fonksiyonumuz gereği negatif sayıları(%v) bölemezsiniz :)", bolunen)
    	}
    	return bolunen / bolen, bolunen % bolen, nil
    }
    ```
    
- ***nil*** Expression
    
    GO’da “nil” ifadesi; slice, array, channel gibi complex veri tiplerinin zero-value(başlangıç değeri)’larıdır.
    
- Packages and Go Install & Build
    
    Dışa açık olacak paketlerdeki, diğer paketler tarafından kullanılacak olan fonksiyon, struct, değişkenler... büyük harfle başlar. 
    
    Paketler şu şekilde oluşturulur. 
    
    ```go
    /* 
    	Proje klasörümüzde go.mod dosyası oluşturup projemizin ana modülüne bir isim
    	veririz
    
    	// go.mod
    		package firstModule
    
    	Proje klasörünün içinde bir paket için bir klasör oluşturduğumuzda bu paket şu
    	şekilde görüntülenir:
    
    	alt paketimiz server olsun.
    		import firstModule/server
    */
    ```
    
    - Go install, aynen go build gibi executable bir dosya oluşturur ancak bu oluşturduğu dosyayı /bin klasörüne taşır ve bağımlılıklarını /pkg klasörüne taşır.
- For Loop
    
    For döngüsü, while gibi şartlı olarak da oluşturulabilir. 
    
    ```go
    i:= 0
    for i< 100 {
    // ...
    	i++
    }
    
    for ;i<100;i++ {
    	
    }
    ```
    
- Switch - Case
    
    Yazılan bir case bir daha yazılamaz. Go’da defaut olarak Break ifadesi her case sonunda kendiliğinden sağlanır. Bu yüzden break yazmak uyarıya neden olacaktır.
    
    ```go
    switch status {
    	case 'a': 
    	case 'b':
    	default:
    }
    // Case bitişlerinde 'break' ifadesine gerek yoktur. 
    // Default kullanılabilir.
    
    // Bir case içinde birden fazla expression yazılacaksa bunlar virgülle ayrılır.
    switch status {
    	case 'a': 
    	case 'b', 'c', 'd':
    	default:
    }
    
    // Expression olmadan da switch yazılabilir.
    		num := 75
        switch { // expression is omitted
        case num >= 0 && num <= 50:
            fmt.Printf("%d is greater than 0 and less than 50", num)
        case num >= 51 && num <= 100:
            fmt.Printf("%d is greater than 51 and less than 100", num)
        case num >= 101:
            fmt.Printf("%d is greater than 100", num)
        }
    
    // Fallthrough, ilk girilen case doğru ya da yanlış dahi olsa case'lerin hepsini
    // gezer ve şartları eşleşen case'leri çalıştırır.
    // Aşağıda 75 hem 51'den hem 52 den büyük olduğu için iki case de çalıştı
    num := 75
    	switch { // expression is omitted
    	case num >= 0 && num <= 50:
    		fmt.Printf("%d is greater than 0 and less than 50", num)
    	case num >= 51 && num <= 100:
    		fmt.Printf("%d is greater than 51 and less than 100", num)
    	case num >= 52 && num <= 120:
    		fmt.Printf("%d is greater than 52 and less than 120", num)
    	case num >= 101:
    		fmt.Printf("%d is greater than 100", num)
    	}
    
    // 75 is greater than 51 and less than 100
    // 75 is greater than 52 and less than 120
    
    // Eğer bir döngü içinde switch-case kullanıyorsak ve bir case çalıştığında döngünün
    // sonlanmasını istiyorsak 'break label' kullanılmalıdır.
    randloop:  
        for {
            switch i := rand.Intn(100); {
            case i%2 == 0:
                fmt.Printf("Generated even number %d", i)
                break randloop
            }
        }
    ```
    
- Arrays
    
    ```go
    // dizinin kaç elemandan oluşacağı biliniyorsa
    cities := [4]string{"istanbul", "ankara", "roma", "kudüs"}
    
    // initialize edilmemiş bir dizi oluşturur. Her elemanın zero-value'si vardır.
    // Bu durumda 0'dır.
    var myArray [5]int
    
    // dizinin kaç elemandan oluşacağı biliniyorsa uzunluğunu belirtmeye gerek yoktur.
    // Üç nokta, dizide kaç eleman olduğunu kendisi tespit edebilir. (compile time'da)
    cities := [...]string{"istanbul", "ankara", "roma", "kudüs"}
    
    // dizini tüm elemanlarını yazmaya gerek yoktur. Yazılmayanlar zero-value olarak
    // doldurulacaktır
    cities := [4]string{"kudüs"}
    // ["kudüs" "" "" ""]
    
    // Boyutları farklı ancak tipleri aynı olan iki dizi karşılaştırıldığında sonuç
    // false olacaktır. Yani boyut da bir bakıma tipe dahildir.
    var arr1 [4]int
    var arr2 [5]int
    isSame := arr1 == arr2 // false
    
    // Diziler, referans tipler değildir. Yani bir dizi başka bir değişkene atanırsa
    // dizinin kendisi dedğil yalnızca içindeki değerler geçer. Bir dizide bir değişiklik
    // yapıldığında diğer dizi bundan etkilenmeyecektir.
    
    // Çok boyutlu diziler de oluşturulabilir.
    multiArr := [3][4]int{}
    
    // Dizinin boyutu len fonksiyonu ile kontrol edilebilir.
    len(myArray)
    ```
    
- For - Range
    
    Dizinin(collection) elemanları üzerinde dönmeye yarar. 
    
    ```go
    cities := [4]string{"istanbul", "ankara", "roma", "kudüs"}
    
    for index, value := range cities {
    	fmt.Println(index, value)
    }
    
    // alternative
    for _ , value := range cities {
    	fmt.Println(value)
    }
    ```
    
- Slices
    
    Slice’lar, mevcut dizilere sadece bir referanstır. Kendi verileri yoktur.
    
    ```go
    // Slice'lar aslında aşağıda görüleeceği üzere dizi parçalarıdır.
    // Ancak slice'lar diziler gibi 0'dan da oluşturulabilir.
    myArr := [...]int{0, 2 ,4, 6, 8, 10}
    mySlc := myArr[1:5]
    
    // Boş bir slice bu şekilde oluşturulabilir ancak uzunluğu bilinmediği için içinde
    // herhangi bir değer yoktur. Bu yüzden mySlc[0] = 10 dendiğinde hata verir.
    var mySlc []int
    // []
    
    // Bu şekilde de bir slice oluşturulup ilk değerleri verilebilir.
    mySlc := []int{12, 20, 32, 44}
    
    // Slice'ta bir değişiklik yapıldığında, bağlı olduğu dizi de etkilenir. Çünkü slice'lar
    // tek başına bir şeye sahip değildirler. Sadece dizilerin bir referansıdır.
    myArr := [...]int{29, 31, 33, 35, 37, 39, 41}
    mySlc := myArr[1:5]
    mySlc[0]++
    fmt.Print(mySlc) // [29, 32, 33, 35, 37, 39, 41]
    mySlc2 := myArr[:] // bu durumda dizinin elamanlarının tamamından bir slice 
    // oluşturulacak ama bu slice'da diziye referans olacak. Değişiklikler diziyi de etkiler
    
    myArr := [...]int{29, 31, 33, 35, 37, 39, 41}
    mySlc := myArr[1:5]
    // bu slice'ın kapasitesi 6'dır. Kapasite, slie'ın start index'inden slice yapılan
    // dizinin son elemanına kadardır. Yani 1. index'ten sona kadar.
    
    // make fonksiyonu ile slice oluşturulabilir.
    // ilk parametre tipi, ikinci parametre slice boyutu, üçüncü parametre(isteğe bağlı) ise
    // slice'ın kapasitesidir. Kapasite boyuttan küçük olamaz.
    mySlc := make([]int, 5, 10)
    
    // slice'lara eleman eklenebilir.
    mySlc := make([]int, 5)
    mySlc = append(mySlc, 3,3,3)
    
    // slice'lardan eleman silerken gerekli yerlerin alt slice'larını alırız.
    mySlc := []int{0,2,4,6,8,10}
    mySlc = mySlc[:len(mySlc)-3]
    // slice'ın son iki elemanını siler.
    
    mySlc := []int{0,2,4,6,8,10}
    mySlc = mySlc[2:]
    //slice'ın ilk iki elemanını siler
    
    mySlc := []int{0,2,4,6,8,10}
    mySlc = append(mySlc[:2], mySlc[3:])
    // slice'ın 2. index'ini siler.
    
    // Slice'lar referans veri tipleri olduğundan, bir fonksiyona argüman olarak
    // geçtiklerinde adresleri geçer. Yani fonksiyonda yapılan bir değişiklik orijinal
    // slice'ı da etkileyecektir.
    ```
    
- Maps
    
    Python’daki dictionary ile aynıdır. Ancak tabi statik tiplemeli. Elemanların index değerleri yoktur.
    
    ```go
    // Key ve value'ler kendi içilerinde tipe sahiptir. Key'ler string, value'ler int olacak
    // Her elemandan sonra virgül koyulması zorunludur.
    grades := map[string]int{
    	"said": 51,
    	"ahmet": 21,
    	"tuğçe": 85,
    	"tuğkan": 0,
    }
    fmt.Println(grades) // map[ahmet:21 said:51 tuğkan:0 tuğçe:85]
    fmt.Println(grades["said"]) // 51
    
    // Yazılan key eğer mapte yoksa geriye, value'nin zero-value'si yani 0 dönecektir.
    fmt.Println(grades["fatma"]) // 0
    
    // Tuğkan'ın değeri 0. Ama Fatma da mapte olmadığı için 0 dönecek. Bunları nasıl
    // ayıracağız?
    value, ok := grades["fatma"] // ok = false, value = 0
    // ok, false ise mapte yok demektir.
    value, ok := grades["tuğkan"] // ok = true, value = 0
    // ok, true ise mapte var demektir.
    
    // make metodu ile de map oluşturulabilir.
    grades := make(map[string]int)
    
    // map'lere eleman eklenip çıkartılabilir.
    grades["Göksel"] = 45
    delete(grades, "said")
    
    // map'lerin uzunluğu len fonksiyonu ile bulunabilir.
    len(grades) // 4
    
    // Map'ler referans veri tipidir. Yani bir map'i başka bir değişkene atadıyıp bir değeri
    // değiştirdiğimizde orijinal map de değişir.
    
    // Map'lerde for döngüsü ile gezilebilir.
    for k,v := range grades {
    	fmt.Println(k, v)
    }
    
    // Mapin zero-value'si nil'dir.
    
    // Map'ler karşılaştırılamaz. Bir Map ancak nil mi diye karşılaştırılabilir.
    
    // Inıtalize edilmemiş bir map'e eleman eklenemez.
    ```
    
- String
    
    Byte dizileridir
    
    ```go
    // String üzerinde de döngü ile gezilebilir.
    
    // %s format specifier ile kullanılabilir.
    fmt.Printf("%s", myString)
    
    // %c ile string karakterleri döngü ile tek tek yazdırılarak string yazdırılabilir.
    
    // Rune tipinde karakterlerin unicode karşılıkları ile oluşturulan bir slice ile
    // string oluşturulabilir.
    runeSlice := []rune{0x0053, 0x0065, 0x00f1, 0x006f, 0x0072}
        str := string(runeSlice)
        fmt.Println(str) // Señor
    
    // string uzunluğu len fonksiyonu ile bulunur
    myString := "Said Taylan"
    len(myString) // 11
    
    // string'lerin eşitliği == operatörü ile karşılaştırılabilir.
    
    // String birleştirme
    string1 := "Muhammed Said"
    string2 := "Taylan"
    total := string1 + "" + string2
    
    // Sprintf fonksiyonu formatlanmış bir stringg geri döner.
    formattedString := fmt.Sprintf("%s %s", string1 , string2)
    
    // STringler immutable(değiştirlemez) veri tipleri olduğundan string'leri değiştirmek
    // için string'i öncelikle "rune dizisi"ne çevirmek daha sonra üzerinde değişiklik
    // yapmak gerekir.
    func mutate(s []rune) string {
    	s[0] = 'a'
    	return string(s)
    }
    func main() {
    	h := "hello"
    	fmt.Println(mutate([]rune(h)))
    }
    ```
    
- Struct
    
    Farklı veri tiplerini bir arada tutmaya yarayan bir veri tipidir. 
    
    ```go
    var myStruct struct {
    name string,
    lastName string,
    age int8
    children []string
    }
    
    myStruct.name = "Said"
    myStruct.lastName = "Taylan"
    myStruct.age = 21
    myStruct.children = []string{"dilruba", "dilara"}
    // yukarıdaki gibi struct'ı değişken olarak tanımlamak iyi değildir ve zaten kullanılmaz
    
    // struct tip olarak tanımlanır ve oluşturulan değişkenler bu tipte tanımlanır.
    type myStruct struct {
    name string
    lastName string
    age int8
    children []string
    }
    
    var person myStruct = myStruct{
    name: "Said",
    lastName: "Taylan",
    age: 21
    children []string{"dilruba", "dilara"}
    }
    
    // struct alanları, isim vermeden de tanımlama sırasına göre yazılabilir.
    type Employee struct {  
        firstName, lastName string
        age       int
        salary    int
    }
    emp2 := Employee{"Thomas", "Paul", 29, 800}
    
    fmt.Print(person.name, person.lastName)
    
    // Struct'lar referans veri türleri değildir JS'nin aksine.
    
    // OOP'taki inheritance kavramına benzemektedir. Manager, myStruct'tan miras alır.
    type myStruct struct {
    name string
    lastName string
    age int8
    children []string
    }
    
    type manager struct {
    myStruct myStruct
    department string
    salary int32
    }
    
    man := manager{
    		myStruct: myStruct{
    			name:     "said",
    			lastName: "taylan",
    			age:      25,
    			children: []string{},
    		},
    		department: "IT",
    		salary: 5600,
    	}
    // alternatively
    man := manager{}
    	man.name = "said"
    	man.lastName = "taylan"
    	man.age=21
    	man.children = []string{}
    	man.department = "IT"
    	man.salary = 5600
    
    // Anonymous struct; değişken tanımlama anında tanımlanan struct'tır.
    boss := struct {
    	name string
    	age int8
    }{"THE BOSS", 55}
    
    // isimsiz alanlar da oluşturulabilir. Tipin adı alan adı olacaktır. Bu yüzden bir
    // struct içinde aynı tipte birden fazla field olamaz.
    type Person struct {  
        string
        int
    }
    
    func main() {  
        p1 := Person{
            string: "naveen",
            int:    50,
        }
        fmt.Println(p1.string)
        fmt.Println(p1.int)
    }
    
    // Struct'ların ve struct alanlarının ilk harfler büyük olursa bunlara dış paketlerden
    // erişilebilir.
    
    // Eğer struct'ların field'ları eşit ise struct'lar eşittir. Eğer alanlar 
    // karışılaştırılabilir ise struct'lar karşılaştırılabilirdir. Yani field'lar içinde
    // map gibi fields'lar varsa struct'lar karşılaştırılamaz. Hata verecektir.
    ```
    
- Methods
    
    Tiplere özel fonksiyonlar tanımlanmasıdır. Bir nevi OOP’taki metotlar gibi
    
    ```go
    type Employee struct {  
        name     string
        salary   int
        currency string
    }
    
    func (e Employee) displaySalary() {  
        fmt.Printf("Salary of %s is %s%d", e.name, e.currency, e.salary)
    }
    
    func main() {  
        emp1 := Employee {
            name:     "Sam Adolf",
            salary:   5000,
            currency: "$",
        }
        emp1.displaySalary()
    }
    
    // Methods vs Functions
    // Her fonksiyondan yalnızca bir tane yapılabilir ancak her tip için bir metot 
    // yazzılabilir. İkinci olarak ise OOP felsefesini uygulamak için bir yaklaşımdır.
    // Ve ayrıca bence daha hoş gözükmektedir.
    
    // Tipleri pointer ile göndermek, metot içinde tipte yapılacak bir değişikliği
    // tipin kendisine de gerçekleştirir.
    /*
    Method with value receiver
    */
    func (e Employee) changeName(newName string) {  
        e.name = newName
    }
    
    /*
    Method with pointer receiver  
    */
    func (e *Employee) changeAge(newAge int) {  
        e.age = newAge
    }
    
    func main() {  
        e := Employee{
            name: "Mark Andrew",
            age:  50,
        }
        fmt.Printf("Employee name before change: %s", e.name)
        e.changeName("Michael Andrew")
        fmt.Printf("\nEmployee name after change: %s", e.name)
    
        fmt.Printf("\n\nEmployee age before change: %d", e.age)
        e.changeAge(51)
        fmt.Printf("\nEmployee age after change: %d", e.age)
    }
    //! Value receiver, aslında bir pointer da alabilir.
    
    // Bir nested struct'ın metoduna tip olarak parent struct gönderilse de sorunsuz
    // çalışacaktır çünkü GO bunu kendisi algılayacaktır.
    type address struct {  
        city  string
        state string
    }
    
    func (a address) fullAddress() {  
        fmt.Printf("Full address: %s, %s", a.city, a.state)
    }
    
    type person struct {  
        firstName string
        lastName  string
        address
    }
    
    func main() {  
        p := person{
            firstName: "Elon",
            lastName:  "Musk",
            address: address {
                city:  "Los Angeles",
                state: "California",
            },
        }
    
        p.fullAddress()
    
    }
    ```
    
- Custom Types
    
    Kendi tiplerimiz oluşturulabilir. En büyük faydası tiplere özel metotlar oluşturabilmektedir. 
    
    ```go
    type mile float64
    type kilometer float64
    // artık mile, float64 özellikleri gösteren bir tiptir. Ekstra fonksiyonalite de
    // eklenebilir.
    
    func toKilometer(m mile) kilometer {
    	return mile/1.6
    }
    ```
    
- Reflect
    
    Reflect paketi run-time’da verilerin ve yapıların tiplerini, verilerini, türlerini vesaire saptamaya yarar.
    
    ### Typeof - Valueof
    
    ```go
    package main
    
    import (  
        "fmt"
        "reflect"
    )
    
    type order struct {  
        ordId      int
        customerId int
    }
    
    func createQuery(q interface{}) {  
        t := reflect.TypeOf(q)
        v := reflect.ValueOf(q)
        fmt.Println("Type ", t)
        fmt.Println("Value ", v)
    
    }
    func main() {  
        o := order{
            ordId:      456,
            customerId: 56,
        }
        createQuery(o)
    
    }
    
    // output
    Type  main.order  
    Value  {456 56}
    ```
    
    ### Typeof vs Kind
    
    ```go
    func createQuery(q interface{}) {  
        t := reflect.TypeOf(q)
        k := t.Kind()
        fmt.Println("Type ", t)
        fmt.Println("Kind ", k)
    
    }
    func main() {  
        o := order{
            ordId:      456,
            customerId: 56,
        }
        createQuery(o)
    
    }
    
    // output
    Type  main.order  
    Kind  struct
    ```
    
    ### NumField - Field
    
    ```go
    func createQuery(q interface{}) {  
        if reflect.ValueOf(q).Kind() == reflect.Struct {
            v := reflect.ValueOf(q)
            fmt.Println("Number of fields", v.NumField())
            for i := 0; i < v.NumField(); i++ {
                fmt.Printf("Field:%d type:%T value:%v\n", i, v.Field(i), v.Field(i))
            }
        }
    
    }
    func main() {  
        o := order{
            ordId:      456,
            customerId: 56,
        }
        createQuery(o)
    }
    
    // output
    Number of fields 2  
    Field:0 type:reflect.Value value:456  
    Field:1 type:reflect.Value value:56
    ```
    
- Pointer
    
    ```go
    // Pointer’lerin tipleri de aynı olmalıdır. String değerin adresini tutan bir
    // pointer’da int bir değerin adresi saklanamaz.
    
    // Go'da Pointer bildiğimiz C'deki gibi kullanılmaktadır. Sadece veri tipi çok önemli 
    
    // Oldukça büyük bir dizi, fonksiyona argüman olarak giderse bu dizinin kopyasınını
    // alınması büyük bir maliyettir. Bunun için büyük verileri pointer yardımıyla geçirmek
    // daha mantıklıdır.
    
    // Pointer'lerin zero-value'si nil'dir.
    
    // new fonksiyonu, kendisine argüman olarak verilen tipte bir değişken oluşturup
    // adresini geri döndürür.
    newVar := new(int32)
    
    Pointer
    
    x := 5
    change(&x)
    fmt.Print(x) // x: 10
    
    func change(x *int) {
    	*x = 10;
    }
    
    func returnPointer() *int {
    	a := 12+3
    	return &a
    }
    
    // Bir fonksiyona argüman olarak bir dizinin adresini pointer yardımıyla geeçirip
    // dizide değişiklik yapmak yerine argüman olarak slice göndermek daha kullanışlı bir
    // yoldur ki slice'lar da bu yüzden vardır zaten :) 
    func modify(sls []int) {  
        sls[0] = 90
    }
    
    func main() {  
        a := [3]int{89, 90, 91}
        modify(a[:])
        fmt.Println(a)
    }
    
    // Golang, pointer aritmetiğini desteklemez.
    ```
    
- Interface
    
    Normalde .Net tarafındaki interface kavramını düşündüğümüzde nesne yönelimli programlama dillerinin temel özelliklerinden olan çok biçimlilik*(Polymorphysm)* ve kalıtımı*(Inheritance)* destekleyen bir tip olarak kullanıldığını görürüz. Bu açıdan bakıldığında bir arayüz içerisinde onu uygulayan diğer tiplerin sahip olması gereken özelliklerin ve yapması gereken aksiyonların tanımlanması söz konusudur. Ancak Go, nesne yönelimli bir dil değildir ve interface onun tip sisteminin önemli bir karakteristiğini yansıtmaktadır: Bir tipin hangi verilere sahip olması gerektiğinden ziyade hangi aksiyonları icra etmesi gerektiğinin soyutlanmasıdır. Bir fonksiyona ya da herhangi bir yere hangi tipin geleceğinden çok gelecek tipin uygulayacağı metotlar önemliyse burada interface kullanılabilir. 
    
    ```go
    package main
     
    import (
        "fmt"
        )
         
    func main(){
        actors:=[]Actor{Tank{"T-80",100},Player{"Gun Ball"}}
        for _,a:=range actors{
            a.SaySomething("hello")
            a.Move("left")
        }
    }
     
    type Actor interface{
        Move(direction string)
        SaySomething(speach string)
    }
     
    type Tank struct{
        model string
        power int
    }
    func(t Tank) SaySomething(s string){
        fmt.Printf("'%s' says : %s\n",t.model,s)
    }
    func(t Tank) Move(d string){
        fmt.Printf("'%s' move to %s\n",t.model,d)
    }
     
    type Player struct{
        name string
    }
    func(p Player) Move(d string){
        fmt.Printf("'%s' move to %s\n",p.name,d)
    }
    func(p Player) SaySomething(s string){
        fmt.Printf("'%s' says %s\n",p.name,s)
    }
    
    // main fonksiyonunun içindeki slice içinde birden fazla farklı tip var. Bu, interface
    // sayesinde oluyor. Actor, bir interface; ve interface olduğu için slice içinde farklı
    // iki veri tipi kullanılabildi. Bu tipler için önemli olan şey kullancağı metodlar.
    // İki veri tipinin de kullanacağı metotlar interface içinde belirtildiği için ortak
    // yanları bu. Interface içinde tanımlanmayan bir metot, tip tarafından kullanılamaz
    // ancak interface'de tanımlanan metodlar kullanılmak zorunda değildir.
    // Kısaca interface, tipler için kullanılmasını istediğimiz metotlar için bize bir şablon
    // verir.
    
    // Ayrıca bir de interface tip olarak kullanılabilir. Hangi tipin geleceğini
    // kestiremediğimiz parametrelerde interface{} kullanabiliriz. Böylece oraya
    // int, float, bool ya da herhangi bir veri tipi gelebilir.
    // Bu interface tipinin içine metot yazılma zorunluluğu da yoktur. İçi boş olabilir.
    
    // Type Assertion, tipi interface olarak verilmiş olan değerin asıl tipine geri
    // döndürülmesidir.
    package main
    
    import (  
        "fmt"
    )
    
    func assert(i interface{}) {  
        v, ok := i.(int)
    // i ile gelen, tipleri interface olan 56 ve "Steven Paul" argümanlarını int'e 
    // çevirmeyi dener. Eğer altta yatan tipi zaten int ise başarılı bir şekilde 
    // çevrilecek ve ok değişkeni true olacak. Ancak altta yatan(underlying) tip int
    // değil ise "ok" değişkeni false olacak. 
        fmt.Println(v, ok)
    }
    func main() {  
        var s interface{} = 56
        assert(s)
        var i interface{} = "Steven Paul"
        assert(i)
    }
    
    // Bir fonksiyona interface olarak farklı veri tipleri gelebileceği için bunu 
    // switch-case ile yapmak iyi olacaktır. 
    func findType(i interface{}) {
    	switch i := i.(type) {
    	case string:
    		fmt.Printf("I am a string and my value is %s\n", i)
    	case int:
    		fmt.Printf("I am an int and my value is %d\n", i)
    	default:
    		fmt.Printf("Unknown type\n")
    	}
    }
    func main() {
    	findType("Naveen")
    }
    
    // ---------------------------------------------------------------
    
    // Pointer olarak tanımlanmayan bir interface, pass by pointer ile metota geçirilmiş
    // bir tip ile kullanılamaz. Yani o tip o interface'ye atanamaz.
    type Describer interface {  
        Describe()
    }
    type Person struct {  
        name string
        age  int
    }
    
    func (p Person) Describe() { //implemented using value receiver  
        fmt.Printf("%s is %d years old\n", p.name, p.age)
    }
    
    type Address struct {  
        state   string
        country string
    }
    
    func (a *Address) Describe() { //implemented using pointer receiver  
        fmt.Printf("State %s Country %s", a.state, a.country)
    }
    
    func main() {  
        var d1 Describer
        p1 := Person{"Sam", 25}
        d1 = p1
        d1.Describe()
        p2 := Person{"James", 32}
        d1 = &p2
        d1.Describe()
    
        var d2 Describer
        a := Address{"Washington", "USA"}
    
        /* compilation error if the following line is
           uncommented
           cannot use a (type Address) as type Describer
           in assignment: Address does not implement
           Describer (Describe method has pointer
           receiver)
        */
        //d2 = a
    
        d2 = &a //This works since Describer interface
        //is implemented by Address pointer in line 22
        d2.Describe()
    
    }
    
    // Interface'nın zero-value'si nil'dir.
    type Describer interface {  
        Describe()
    }
    
    func main() {  
        var d1 Describer
        if d1 == nil {
            fmt.Printf("d1 is nil and has type %T value %v\n", d1, d1)
        }
    }
    
    // Initialize edilmemiş yani nil olan bir interface kullanılmaya çalışılırsa panic
    // atacaktır.
    
    // Çoklu interface. Kodda göstermek istediğim şey aslında interface'nin tip olarak
    // nasıl kullanıldığını göstermek
    type SalaryCalculator interface {  
        DisplaySalary()
    }
    
    type LeaveCalculator interface {  
        CalculateLeavesLeft() int
    }
    
    type Employee struct {  
        firstName string
        lastName string
        basicPay int
        pf int
        totalLeaves int
        leavesTaken int
    }
    
    func (e Employee) DisplaySalary() {  
        fmt.Printf("%s %s has salary $%d", e.firstName, e.lastName, (e.basicPay + e.pf))
    }
    
    func (e Employee) CalculateLeavesLeft() int {  
        return e.totalLeaves - e.leavesTaken
    }
    
    func main() {  
        e := Employee {
            firstName: "Naveen",
            lastName: "Ramanathan",
            basicPay: 5000,
            pf: 200,
            totalLeaves: 30,
            leavesTaken: 5,
        }
        var s SalaryCalculator = e
        s.DisplaySalary()
        var l LeaveCalculator = e
        fmt.Println("\nLeaves left =", l.CalculateLeavesLeft())
    }
    // Bir tip oluşturulur ve interface'ye atanır.
    
    // Birden çok interface bir interface çatısı altında nested olarak kullanılabilir.
    type SalaryCalculator interface {  
        DisplaySalary()
    }
    
    type LeaveCalculator interface {  
        CalculateLeavesLeft() int
    }
    
    type EmployeeOperations interface {  
        SalaryCalculator
        LeaveCalculator
    }
    
    type Employee struct {  
        firstName string
        lastName string
        basicPay int
        pf int
        totalLeaves int
        leavesTaken int
    }
    
    func (e Employee) DisplaySalary() {  
        fmt.Printf("%s %s has salary $%d", e.firstName, e.lastName, (e.basicPay + e.pf))
    }
    
    func (e Employee) CalculateLeavesLeft() int {  
        return e.totalLeaves - e.leavesTaken
    }
    
    func main() {  
        e := Employee {
            firstName: "Naveen",
            lastName: "Ramanathan",
            basicPay: 5000,
            pf: 200,
            totalLeaves: 30,
            leavesTaken: 5,
        }
        var empOp EmployeeOperations = e
        empOp.DisplaySalary()
        fmt.Println("\nLeaves left =", empOp.CalculateLeavesLeft())
    }
    ```
    
- Variadic Functions
    
    Fonksiyona kaç argüman geleceği bilinemediği zamanlarda kullanılır. Teorik olarak sınırsız sayıda argüman alabilir. 
    
    ```go
    // myFunc fonksiyonuna birçok argüman geçti. Geçen argümanlar bir slice şeklinde geçer.
    func main() {
    	myFunc(true, 4, 5.4, 6, 7, "hello said", 9)
    }
    
    func myFunc(args ...interface{}) {
    	fmt.Printf("%#v", args)
    }
    
    // Yalnızca son parametre variadic olabilir.
    
    // Variadic parametreye 0 argüman da geçelebilir.
    
    // Bir slice'ı thre dot ile variadic argument olarak geçirebiliriz.
    func mySliceFunc(args ...int) {
    	for _, v := range args {
    		fmt.Print(v)
    	}
    }
    theSlice := []int{5,10,15,20,25,30}
    mySliceFunc(theSlice...)
    
    // Bir slice parçalanıp variadic olarak bir fonksiyona geçtiğinde artık yeni bir slice
    // oluşturulacağından fonksiyondaki slice'ta yapılan değişiklik ana slice'ı
    // etkilemeyecektir.
    ```
    
- Goroutines
    
    Daha az kaynak kullanan ve daha zarif bir thread gibi düşünülebilir. Bir thread oluşturulduğunda sabit bir boyuta sahiptir ancak goroutine’ler ihtiyaca göre daralıp genişleyebilir. 
    
    ```go
    // Main fonksiyonu da bir goroutine'dir. Goroutine'lerin bitmesini beklemeden biter.
    // Diğer goroutine'ler ile iletişim kurulması lazım ki goroutine'nin bittiğini anlasın
    
    package main
    
    import (  
        "fmt"
        "time"
    )
    
    func numbers() {  
        for i := 1; i <= 5; i++ {
            time.Sleep(250 * time.Millisecond)
            fmt.Printf("%d ", i)
        }
    }
    func alphabets() {  
        for i := 'a'; i <= 'e'; i++ {
            time.Sleep(400 * time.Millisecond)
            fmt.Printf("%c ", i)
        }
    }
    func main() {  
        go numbers()
        go alphabets()
        time.Sleep(3000 * time.Millisecond)
        fmt.Println("main terminated")
    }
    
    // Main fonksiyonunun goroutine'leri beklemesini basit bir time işlevi ile de
    // bekeltebiliriz ancak bu verimsiz bir yoldur ve diğer goroutine'lerin ne zaman 
    // biteceğini her zaman kestiremeyiz. Bu yüzden Channels kullanılır. 
    ```
    
- Channels
    - Temeller ve Unbuffered Channels
        
        ```go
        // Go-routine'ler ile birlikte kullanılır.
        // Verinin bir uçtan diğer uca taşınmasını sağlayan yollardır.
        
        // Zero-value'si nil'dir.
        
        // Initialize edilmemiş bir channel'de herhangi bir veri taşınamaz.
        // Bu yüzden channel oluşturmak için make fonksiyonu kullanılır.
        func main() {  
            var a chan int
            if a == nil {
                fmt.Println("channel a is nil, going to define it")
                a = make(chan int)
                fmt.Printf("Type of a is %T", a)
            }
        }
        
        // Taşınacak verinin türü ile channel tipi aynı olmalıdır.
        
        // a kanalındaki veri okunup data değişkenine aktarılır.
        // Alttaki satırda ise datadaki veri a kanalına giriyor.
        // Dışa dönük ok, a'dan veri okunacağını, a'ya dönük olan ok ise a kanalına
        // yazılacağını söyler.
        data := <- a // read from channel a  
        a <- data // write to channel a
        
        // Channel'deki veri okunmadan channel'e veri yazılamaz. Bunun sayesinde main
        // fonksiyonunun goroutine'yi beklemesi sağlanabilir.
        
        // Daha çok güvenliği sağlamak için kullanılan unidirectional kanallar
        // oluşturulabilir. Kanal yine çift yönlü olarak oluşturulur. Ancak bir fonksiyona
        // tek yönlü kanal gönderilmesi için parametre tek yönlü olarak tanımlanır.
        // Ya da return değeri tek yönlü olarak yazılır. Böylece fonksiyondan dönen
        // kanalın kötüye kullanımının önüne geçilmiş olur.
        func sendData(sendch chan<- int) {  
            sendch <- 10
        }
        
        func main() {  
            chnl := make(chan int)
            go sendData(chnl)
            fmt.Println(<-chnl)
        }
        
        func F() <-chan int {
            // Create a regular, two-way channel.
            c := make(chan int)
        
            go func() {
                defer close(c)
        
                // Do stuff
                c <- 123
            }()
        
            // Returning it, implicitely converts it to read-only,
            // as per the function return value.
            return c
        }
        
        // Bir kanal close() fonksiyonu sayesinde kapatılabilir. Artık kanal üzerinden veri
        // gönderilip alınamaz.
        // "v, ok:= <-chnl"
        // Yukarıdaki gibi eğer ok değişkeni false ise kanal kapalıdır. Açık ise veri
        // başarıyla ulaşmıştır. Eğer kanal akapalı ise value, kanalın zero-value'si olur.
        func producer(chnl chan int) {
        	for i := 0; i < 10; i++ {
        		chnl <- i
        	}
        	close(chnl)
        }
        func main() {
        	ch := make(chan int)
        	go producer(ch)
        	for {
        		v, ok := <-ch
        		if !ok {
        			break
        		}
        		fmt.Println("Received ", v, ok)
        	}
        }
        
        // For-range yardımıyla kanalın içindeki veriler üzerinde gezinilebilir.
        // Elemanın üzerinde gezinildiğinde içindeki dedğerin okunduğu anlamına gelir.
        // Kanal kapandığında ise döngü biter.
        func producer(chnl chan int) {
        	for i := 0; i < 10; i++ {
        		chnl <- i
        	}
        	close(chnl)
        }
        func main() {
        	ch := make(chan int)
        	go producer(ch)
        	for v := range ch {
        		fmt.Println("Received ", v)
        	}
        } 
        
        // iç içe goroutine ve channel kullanımına güzel bir örnek
        func digits(number int, dchnl chan int) {  
            for number != 0 {
                digit := number % 10
                dchnl <- digit
                number /= 10
            }
            close(dchnl)
        }
        func calcSquares(number int, squareop chan int) {  
            sum := 0
            dch := make(chan int)
            go digits(number, dch)
            for digit := range dch {
                sum += digit * digit
            }
            squareop <- sum
        }
        
        func calcCubes(number int, cubeop chan int) {  
            sum := 0
            dch := make(chan int)
            go digits(number, dch)
            for digit := range dch {
                sum += digit * digit * digit
            }
            cubeop <- sum
        }
        
        func main() {  
            number := 589
            sqrch := make(chan int)
            cubech := make(chan int)
            go calcSquares(number, sqrch)
            go calcCubes(number, cubech)
            squares, cubes := <-sqrch, <-cubech
            fmt.Println("Final output", squares+cubes)
        }
        ```
        
    - Buffered Channel
        
        ```go
        /*
        	Bu zamana kadarki channeller unbuffered channel'lardı. Bir kanala bir mesaj
        	gönderildikten sonra o mesaj okunana kadar kod bloklanırdı. Bir kanalda sadece
        	bir mesaj olabilirdi. Çünkü işin içinde buffer yoktu.
        	Ancak şimdi buffer dahil olduğu için kuyrukta mesaj bekletebiliyoruz.
        	Kanal tamamen dolu ya da boş olmadığı sürece gönderici/alıcı bloklanmaz.
        	Buffered channel, make() fonksiyonu ile yapılıyor. İkinci argüman, kanalın
        	yani buffer'in kapasitesi. Kanalda en fazla kaç mesaj bulunduğunu belirtiyor.
        	Buffer, FIFO mantığına sahip.
        	Buffer'siz kanallar, goroutine'ler dışında kullanılamıyordu çünkü gönderilen
        	bir mesaj alınana kadar kod bloklanırdı. Ama şimdi birden fazla mesaj
        	gönderilebildiği için kod bloklanmaz(channel boş/dolu olmazsa)
        	newChl := make(chan int, 2)
        */
        func main() {  
            ch := make(chan string, 2)
            ch <- "said"
            ch <- "taylan"
            fmt.Println(<- ch)
            fmt.Println(<- ch)
        }
        
        /*
        	Buffered channel evet FIFO ile hareket eder. Ama channel birden fazla kez
        	kullanıldığında nasıl gerçekleşir. Let's see
        */
        func write(ch chan int) {
        	for i := 0; i < 5; i++ {
        		ch <- i
        		fmt.Println("successfully wrote", i, "to ch")
        	}
        	close(ch)
        }
        func main() {
        	ch := make(chan int, 2)
        	go write(ch)
        	time.Sleep(2 * time.Second)
        	for v := range ch {
        		fmt.Println("read value", v, "from ch")
        		time.Sleep(2 * time.Second)
        
        	}
        }
        
        /* Çıktısı:
        successfully wrote 0 to ch  
        successfully wrote 1 to ch  
        read value 0 from ch  
        successfully wrote 2 to ch  
        read value 1 from ch  
        successfully wrote 3 to ch  
        read value 2 from ch  
        successfully wrote 4 to ch  
        read value 3 from ch  
        read value 4 from ch
        */
        
        // close() ile kapanmıi kanallardan da içindeki verileri okunabilir:
        func main() {  
            ch := make(chan int, 5)
            ch <- 5
            ch <- 6
            close(ch)
            for n := range ch {
                fmt.Println("Received:", n)
            }
        }
        
        // len(chnl), kuyruktaki mesajların sayısını verir.
        ```
        
    - Wait Group
        
        Thread’lerdeki wait() ile benzer işi görür. Ya da Javascript’tki Promise.All gibi düşünülebilir. Goroutine’lerin bitmesini bekler ve programa ondan sonra devam eder. 
        
        ```go
        import (  
            "fmt"
            "sync"
            "time"
        )
        
        func process(i int, wg *sync.WaitGroup) {  
            fmt.Println("started Goroutine ", i)
            time.Sleep(2 * time.Second)
            fmt.Printf("Goroutine %d ended\n", i)
            wg.Done()
        }
        
        func main() {  
            no := 3
            var wg sync.WaitGroup
            for i := 0; i < no; i++ {
                wg.Add(1)
                go process(i, &wg)
            }
            wg.Wait()
            fmt.Println("All go routines finished executing")
        }
        ```
        
    - Worker Pool
        
        ```go
        /*
        	Thread pool gibi düşünülebilir. Az goroutine ile fazla iş yapmayı hedefler.
        	Worker sayısı for döngüsünün dönüş sayısını belirmektedir.
        	Döngüde ise yapılması istenen işin fonksiyonu goroutine ile çalıştırılır.
        	Ana fonksiyon içinde Job ve Result kanalları oluşturulur. İşin fonksiyonu
        	içinde Jobs kanalı üzerinde range ile dönülerek işler yapılır.
        	Yapılan işler Result kanalına atılır. 
        	Job kanalına işler, bir for döngüsü ile gidebilir.
        */ 
        func worker(id int, jobs <-chan int, results chan<- int) {
        	for j := range jobs {
        		fmt.Println("worker", id, "started  job", j)
        		// Yapılacak iş vs...
        		time.Sleep(time.Second)
        		fmt.Println("worker", id, "finished job", j)
        		results <- j * 2
        	}
        }
        
        func main() {
        
        	// İşçilere görev vermek ve sonuçlarını almak için
        	// jobs ve results isimli iki kanal oluşturuyoruz.
        	jobs := make(chan int, 100)
        	results := make(chan int, 100)
        
        	// Uygulamada 3 işçi çalıştırmaktayız. Başlangıçta
        	// bu işçiler bloklanmış durumda çünkü jobs kanalında
        	// herhangi bir iş bulunmamaktadır.
        	for w := 1; w <= 3; w++ {
        		go worker(w, jobs, results)
        	}
        
        	// Burada jobs kanalına 5 görev gönderiyor ve sonrasında
        	// kanalı kapatıyoruz.
        	for j := 1; j <= 5; j++ {
        		jobs <- j
        	}
        	close(jobs)
        
        	// Son olarak sonuçları yazdırıyoruz.
        	for a := 1; a <= 5; a++ {
        		<-results
        	}
        	
        ```
        
    - Select-case
        
        ```go
        /*
        Case'lerde belirtilen expression'lardan önce hangisi hazır olursa o case çalışır
        Eğer hiçbiri çalışmazsa default case çalışır.
        */
        func process(ch chan string) {  
            time.Sleep(10500 * time.Millisecond)
            ch <- "process successful"
        }
        
        func main() {  
            ch := make(chan string)
            go process(ch)
            for {
                time.Sleep(1000 * time.Millisecond)
                select {
                case v := <-ch:
                    fmt.Println("received value: ", v)
                    return
                default:
                    fmt.Println("no value received")
                }
            }
        
        }
        ```
        
    - Mutex
        
        ```go
        /*
        	Race condition için kullanılan bir kilit mekanizmasıdır. Gayet basit çalışır:
        	İşi olan fonksiyon critical section'dan önce Lock() atar ve işi bitince de
        	critical section'dan sonra Unlock() atar.
        */
        var x  = 0  
        func increment(wg *sync.WaitGroup, m *sync.Mutex) {  
            m.Lock()
            x = x + 1
            m.Unlock()
            wg.Done()   
        }
        func main() {  
            var w sync.WaitGroup
            var m sync.Mutex
            for i := 0; i < 1000; i++ {
                w.Add(1)        
                go increment(&w, &m)
            }
            w.Wait()
            fmt.Println("final value of x", x)
        }
        
        /* 
        	Aslında mutex'e bir diğer alternatif channel'dir. Critical setion'dan hemen
        	önce ve sonra 1 kapasiteli kanala okuma ve yazma yaparsak aradaki koda başka
        	kimse erişemez. Çünkü channel'in boyutu zaten 1 ve içindeki veri okunamış.
        	İçindeki veri okunmamışken kendisinden başka bir yazma işlemine izin
        	vermeyeceğinden aradaki kod güvende olur.
        */
        var x  = 0  
        func increment(wg *sync.WaitGroup, ch chan bool) {  
            ch <- true
            x = x + 1
            <- ch
            wg.Done()   
        }
        func main() {  
            var w sync.WaitGroup
            ch := make(chan bool, 1)
            for i := 0; i < 1000; i++ {
                w.Add(1)        
                go increment(&w, ch)
            }
            w.Wait()
            fmt.Println("final value of x", x)
        }
        ```
        
- Object Oriented and GO
    
    ```go
    /*
    	Go'da constructor metodu olmadığından bir New metodu
    	oluşturulabilir. Obje ilk create edildiğinde bu metot çağrılırsa
    	constructor sağlanmış olur.
    */
    type employee struct {  
        firstName   string
        lastName    string
        totalLeaves int
        leavesTaken int
    }
    
    func New(firstName string,
    				lastName string,
    				totalLeave int,
    				leavesTaken int) employee {  
        e := employee {firstName, lastName, totalLeave, leavesTaken}
        return e
    }
    
    func (e employee) LeavesRemaining() {  
        fmt.Printf("%s %s has %d leaves remaining\n", e.firstName, e.lastName,
    								(e.totalLeaves - e.leavesTaken)
    							)
    }
    func main() {  
        e := employee.New("Sam", "Adolf", 30, 20)
    }
    
    /*
    	Go'da inheritance, nested struct'lar ile sağlanabilir. Dış struct, içine aldığı
    	struct'ın alanlarını, sanki kendi alanıymış gibi kullanabilir.
    */
    type author struct {  
        firstName string
        lastName  string
        bio       string
    }
    
    func (a author) fullName() string {  
        return fmt.Sprintf("%s %s", a.firstName, a.lastName)
    }
    
    type blogPost struct {  
        title   string
        content string
        author
    }
    
    func (b blogPost) details() {  
        fmt.Println("Title: ", b.title)
        fmt.Println("Content: ", b.content)
        fmt.Println("Author: ", b.fullName())
        fmt.Println("Bio: ", b.bio)
    }
    
    func main() {  
        author1 := author{
            "Naveen",
            "Ramanathan",
            "Golang Enthusiast",
        }
        blogPost1 := blogPost{
            "Inheritance in Go",
            "Go supports composition instead of inheritance",
            author1,
        }
        blogPost1.details()
    }
    
    /*
    	Slice'lar struct'lara anonymous olarak eklenemez. İsmi de belirtilmelidir.
    */
    type author struct {  
        firstName string
        lastName  string
        bio       string
    }
    
    func (a author) fullName() string {  
        return fmt.Sprintf("%s %s", a.firstName, a.lastName)
    }
    
    type blogPost struct {  
        title   string
        content string
        author
    }
    
    func (p blogPost) details() {  
        fmt.Println("Title: ", p.title)
        fmt.Println("Content: ", p.content)
        fmt.Println("Author: ", p.fullName())
        fmt.Println("Bio: ", p.bio)
    }
    
    type website struct {  
        blogPosts []blogPost
    }
    
    func (w website) contents() {  
        fmt.Println("Contents of Website\n")
        for _, v := range w.blogPosts {
            v.details()
            fmt.Println()
        }
    }
    
    func main() {  
        author1 := author{
            "Naveen",
            "Ramanathan",
            "Golang Enthusiast",
        }
        blogPost1 := blogPost{
            "Inheritance in Go",
            "Go supports composition instead of inheritance",
            author1,
        }
        blogPost2 := blogPost{
            "Struct instead of Classes in Go",
            "Go does not support classes but methods can be added to structs",
            author1,
        }
        blogPost3 := blogPost{
            "Concurrency",
            "Go is a concurrent language and not a parallel one",
            author1,
        }
        w := website{
            blogPosts: []blogPost{blogPost1, blogPost2, blogPost3},
        }
        w.contents()
    }
    
    /*
    	GO'da polymorphism Interface'ler ile sağlanabilir. Interface, kullanılacak
    	metotlları belirtir ve her tip bunu kendisine göre yorumlar.
    */
    ```
    
- Defer
    
    ```go
    /*
    	Fonksiyon tamamlanmadan hemen önce bir fonksiyon/metot çalıştırır.
    */
    type person struct {  
    firstName string
    lastName string
    }
    
    func (p person) fullName() {  
        fmt.Printf("%s %s",p.firstName,p.lastName)
    }
    
    func main() {  
        p := person {
            firstName: "John",
            lastName: "Smith",
        }
        defer p.fullName()
        fmt.Printf("Welcome ")  
    }
    
    /*
    	Çağrılan fonksiyon/metotta herhangi bir argüman varsa, 
    	bu argüman defer'den önce belirtilmelidir.
    */
    func printA(a int) {  
        fmt.Println("value of a in deferred function", a)
    }
    func main() {  
        a := 5
        defer printA(a)
        a = 10
        fmt.Println("value of a before deferred function call", a)
    
    }
    /* result: 
    	value of a before deferred function call 10  
    	value of a in deferred function 5
    */
    
    /*
    	Bir fonksiyonda birden çok defer kullanılabilir.
    	Defer'ler LIFO mantığına göre stack'lanır.
    */
    func main() {  
        name := "Naveen"
        fmt.Printf("Original String: %s\n", string(name))
        fmt.Printf("Reversed String: ")
        for _, v := range []rune(name) {
            defer fmt.Printf("%c", v)
        }
    }
    /* result:
    	Original String: Naveen  
    	Reversed String: neevaN
    */
    
    /* 
    	Defer'in pratik kullanımlarından birisi; WaitGroup kullanıyorsak
    	ve return edilmesi gereken if blokları varsa her blokta wg.Done()
    	yapmaktansa fonksiyonun başında defer wg.Done() yapmak yeterlidir
    */
    ```
    
- Panic and Recover
    
    ```go
    /* 
    	Bazı normal olmayan durumlarda program çalışmaya devam edemez.
    	Bu durumda, 'panic' çalışmayı durdurur. Program çalşmayı sonlandırmadan
    	önce defer statement'leri çalışır. 
    */
    func fullName(firstName *string, lastName *string) {  
        if firstName == nil {
            panic("runtime error: first name cannot be nil")
        }
        if lastName == nil {
            panic("runtime error: last name cannot be nil")
        }
        fmt.Printf("%s %s\n", *firstName, *lastName)
        fmt.Println("returned normally from fullName")
    }
    
    func main() {  
        firstName := "Elon"
        fullName(&firstName, nil)
        fmt.Println("returned normally from main")
    }
    
    /*
    	Oluşan panic'i kurtarmak ve programın çökmesini önlemek için
    	recover() vardır. Return değeri olarka panic sebebini döner.
    	Kurtarıldıktan sonra fonksiyondan çıkıp fonksiyonun
    	çağrıldığı satırdan bir sonraki satırdan kod devam eder.
    */
    func recoverFullName() {  
        if r := recover(); r!= nil {
            fmt.Println("recovered from ", r)
        }
    }
    
    func fullName(firstName *string, lastName *string) {  
        defer recoverFullName()
        if firstName == nil {
            panic("runtime error: first name cannot be nil")
        }
        if lastName == nil {
            panic("runtime error: last name cannot be nil")
        }
        fmt.Printf("%s %s\n", *firstName, *lastName)
        fmt.Println("returned normally from fullName")
    }
    
    func main() {  
        defer fmt.Println("deferred call in main")
        firstName := "Elon"
        fullName(&firstName, nil)
        fmt.Println("returned normally from main")
    }
    /* result:
    	recovered from  runtime error: last name cannot be nil
    	returned normally from main
    	deferred call in main
    */
    
    /*
    	Recover() edildikten sonra panic'in stack trace'si kaybolur
    	yani nerelerden nerelere sıçrayarak bu hataya ulaştık.
    	Bunu görmek için debug paketini import ediyoruz.
    */
    import (  
        "fmt"
        "runtime/debug"
    )
    
    func recoverFullName() {  
        if r := recover(); r != nil {
            fmt.Println("recovered from ", r)
            debug.PrintStack()
        }
    }
    
    func fullName(firstName *string, lastName *string) {  
        defer recoverFullName()
        if firstName == nil {
            panic("runtime error: first name cannot be nil")
        }
        if lastName == nil {
            panic("runtime error: last name cannot be nil")
        }
        fmt.Printf("%s %s\n", *firstName, *lastName)
        fmt.Println("returned normally from fullName")
    }
    
    func main() {  
        defer fmt.Println("deferred call in main")
        firstName := "Elon"
        fullName(&firstName, nil)
        fmt.Println("returned normally from main")
    }
    /*  result:
    	recovered from  runtime error: last name cannot be nil  
    	goroutine 1 [running]:  
    	runtime/debug.Stack(0x37, 0x0, 0x0)  
        /usr/local/go-faketime/src/runtime/debug/stack.go:24 +0x9d
    	runtime/debug.PrintStack()  
        /usr/local/go-faketime/src/runtime/debug/stack.go:16 +0x22
    	main.recoverFullName()  
        /tmp/sandbox771195810/prog.go:11 +0xb4
    	panic(0x4a1b60, 0x4dc300)  
        /usr/local/go-faketime/src/runtime/panic.go:969 +0x166
    	main.fullName(0xc0000a2f28, 0x0)  
        /tmp/sandbox771195810/prog.go:21 +0x1cb
    	main.main()  
        /tmp/sandbox771195810/prog.go:30 +0xc6
    	returned normally from main  
    	deferred call in main  
    */
    
    /*
    	Başka bir goroutine'deki panic'i rercover() etmek mümkün değildir.
    */
    func recovery() {  
        if r := recover(); r != nil {
            fmt.Println("recovered:", r)
        }
    }
    
    func sum(a int, b int) {  
        defer recovery()
        fmt.Printf("%d + %d = %d\n", a, b, a+b)
        done := make(chan bool)
        go divide(a, b, done)
        <-done
    }
    
    func divide(a int, b int, done chan bool) {  
        fmt.Printf("%d / %d = %d", a, b, a/b)
        done <- true
    
    }
    
    func main() {  
        sum(5, 0)
        fmt.Println("normally returned from main")
    }
    ```
    
    - First Class Function
        
        Anonymous functions olarak da düşünülebilir. Bir isimsiz fonksiyonun bir değişkene atanması, bir fonksiyona parametre olarak geçmesi ve bir fonksiyonun return edilmesi 
        
        ```go
        // Anonymous functions
        func main() {  
            a := func() {
                fmt.Println("hello world first class function")
            }
            a()
            fmt.Printf("%T", a)
        }
        
        // Tanımlanan bir anonymous function değişkene atanmadan hemen çalıştırılabilir
        func main() {  
            func() {
                fmt.Println("hello world first class function")
            }()
        }
        
        // Çağrılan fonksiyona parametre de verilebilir.
        func main() {  
            func(n string) {
                fmt.Println("Welcome", n)
            }("Gophers")
        }
        
        /*	
        	Tip tanımlar gibi fonksiyon imzası ile tip tanımlanıp bu tipte
        	oluşturulan bir değşşkeneanonymous function atanabilir.
        */
        type add func(a int, b int) int
        
        func main() {  
            var a add = func(a int, b int) int {
                return a + b
            }
            s := a(5, 6)
            fmt.Println("Sum", s)
        }
        
        /* 
        	High Order Functions: Bir fonksiyona argüman olarak bir fonksiyon verilmesi
        	ya da bir fonksiyonun return olarak bir fonksiyon dönmesi
        */
        func simple(a func(a, b int) int) {  
            fmt.Println(a(60, 7))
        }
        
        func main() {  
            f := func(a, b int) int {
                return a + b
            }
            simple(f)
        }
        
        /*
        	Closure Functions: Bir fonksiyonun, kendisini kapsayan
        	fonksiyon/fonksiyonların değişkenlerine erişmesi.
        	Kullanımında, içteki fonksiyon anladığım kadarıyla return edilmek zorunda
        	ama eğer return edilmezse çağrılmak zorunda. Eğer return edilirse döndüğü
        	yerde parantezler ile içteki fonksiyon çağrılabiliyor.
        */
        func appendStr() func(string) string {  
            t := "Hello"
            c := func(b string) string {
                t = t + " " + b
                return t
            }
            return c
        }
        
        func main() {  
            a := appendStr()
            b := appendStr()
            fmt.Println(a("World"))
            fmt.Println(b("Everyone"))
        
            fmt.Println(a("Gopher"))
            fmt.Println(b("!"))
        }
        ```
        
    - Reflect
        
        ```go
        /* 
        	Tipi interface olan bir değişkenin run-time'da Tipini, türünü, değerini
        	tespit etmeyi sağlar. Ancak kod okunurluğunu azalttığı ve bakım maliyetini
        	artırdığı için mümkün olduğuna kaçınılmalıdır.
        */
        
        // reflect.TypeOf(q) ve reflect.ValueOf(q) sırasıyla tip ve değerini verir.
        import (  
            "fmt"
            "reflect"
        )
        
        type order struct {  
            ordId      int
            customerId int
        }
        
        func createQuery(q interface{}) {  
            t := reflect.TypeOf(q)
            v := reflect.ValueOf(q)
            fmt.Println("Type ", t)
            fmt.Println("Value ", v)
        
        }
        func main() {  
            o := order{
                ordId:      456,
                customerId: 56,
            }
            createQuery(o)
        
        }
        /* result:
        	Type  main.order  
        	Value  {456 56}
        */
        
        /*
        	reflect.Kind() bir tipin(type) türünü söyler. Örneğin Order tipinin underlying
        	tipi struct'tır.
        */
        type order struct {  
            ordId      int
            customerId int
        }
        
        func createQuery(q interface{}) {  
            t := reflect.TypeOf(q)
            k := t.Kind()
            fmt.Println("Type ", t)
            fmt.Println("Kind ", k)
        
        }
        func main() {  
            o := order{
                ordId:      456,
                customerId: 56,
            }
            createQuery(o)
        
        }
        /* result:
        	Type  main.order  
        	Kind  struct
        */
        
        /*
        	v.NumField() ve v.Field(i) sırasıyla değeri v olan struct'ın
        	field'larının sayısını ve struct içindeki field'ların sayısal sırasına göre 
        	o field'in değerini verir.
        */
        type order struct {  
            ordId      int
            customerId int
        }
        
        func createQuery(q interface{}) {  
            if reflect.ValueOf(q).Kind() == reflect.Struct {
                v := reflect.ValueOf(q)
                fmt.Println("Number of fields", v.NumField())
                for i := 0; i < v.NumField(); i++ {
                    fmt.Printf("Field:%d type:%T value:%v\n", i, v.Field(i), v.Field(i))
                }
            }
        
        }
        func main() {  
            o := order{
                ordId:      456,
                customerId: 56,
            }
            createQuery(o)
        }
        /* result:
        	Number of fields 2  
        	Field:0 type:reflect.Value value:456  
        	Field:1 type:reflect.Value value:56
        */
        
        // Tam bir örnek
        import (  
            "fmt"
            "reflect"
        )
        
        type order struct {  
            ordId      int
            customerId int
        }
        
        type employee struct {  
            name    string
            id      int
            address string
            salary  int
            country string
        }
        
        func createQuery(q interface{}) {  
            if reflect.ValueOf(q).Kind() == reflect.Struct {
                t := reflect.TypeOf(q).Name()
                query := fmt.Sprintf("insert into %s values(", t)
                v := reflect.ValueOf(q)
                for i := 0; i < v.NumField(); i++ {
                    switch v.Field(i).Kind() {
                    case reflect.Int:
                        if i == 0 {
                            query = fmt.Sprintf("%s%d", query, v.Field(i).Int())
                        } else {
                            query = fmt.Sprintf("%s, %d", query, v.Field(i).Int())
                        }
                    case reflect.String:
                        if i == 0 {
                            query = fmt.Sprintf("%s\"%s\"", query, v.Field(i).String())
                        } else {
                            query = fmt.Sprintf("%s, \"%s\"", query, v.Field(i).String())
                        }
                    default:
                        fmt.Println("Unsupported type")
                        return
                    }
                }
                query = fmt.Sprintf("%s)", query)
                fmt.Println(query)
                return
        
            }
            fmt.Println("unsupported type")
        }
        
        func main() {  
            o := order{
                ordId:      456,
                customerId: 56,
            }
            createQuery(o)
        
            e := employee{
                name:    "Naveen",
                id:      565,
                address: "Coimbatore",
                salary:  90000,
                country: "India",
            }
            createQuery(e)
            i := 90
            createQuery(i)
        
        }
        ```
        
    - Flags
- Flags
    
    ```go
    /*
        Programa flag geçirmeyi sağlar. Gerçi
        environment variable ile flag aynı şey değil ama olsun.
    */
    func main() {
    
        wordPtr := flag.String("selam", "foo", "a string")
    
        numbPtr := flag.Int("numb", 42, "an int")
        forkPtr := flag.Bool("fork", false, "a bool")
    
        // Flag'ın bir değişkene atanmasını sağlar.
        // Diğer flag'lar gibi dereferance yapılmasına gerek yok.
        var svar string
        flag.StringVar(&svar, "svar", "bar", "a string var")
    
        flag.Parse()
    
        fmt.Println("selam:", *wordPtr)
        fmt.Println("numb:", *numbPtr)
        fmt.Println("fork:", *forkPtr)
        fmt.Println("svar:", svar)
        fmt.Println("tail:", flag.Args())
    }
    
    /* result:
        go run main.go -word=opt -numb=7 -fork -svar=flag
    
            word: opt
            numb: 7
            fork: true
            svar: flag
            tail: []
    */
    ```
    
- Read Files
    
    ```go
    /* 
      ioutil kütüphanesindeki ReadFile metodu ile bir anda
      bütün içerik bir anda okunabilir. Ancak okunan karakterler
      byte şeklindedir. Bunların stringify edilmesi gerekir.
    */
    import (  
        "fmt"
        "io/ioutil"
    )
    
    func main() {  
        data, err := ioutil.ReadFile("test.txt")
        if err != nil {
            fmt.Println("File reading error", err)
            return
        }
        fmt.Println("Contents of file:", string(data))
    }
    
    // Flag'ler ile dosya yolu belirtilebilir.
    func main() {  
        fptr := flag.String("fpath", "test.txt", "file path to read from")
        flag.Parse()
        data, err := ioutil.ReadFile(*fptr)
        if err != nil {
            fmt.Println("File reading error", err)
            return
        }
        fmt.Println("Contents of file:", string(data))
    }
    
    /*
    	İçeriği direkt RAM'e yükleyip okumak yerine chunk chunk okunabilir.
    */
    func main() {  
        fptr := flag.String("fpath", "test.txt", "file path to read from")
        flag.Parse()
    
        f, err := os.Open(*fptr)
        if err != nil {
            log.Fatal(err)
        }
        defer func() {
            if err = f.Close(); err != nil {
                log.Fatal(err)
            }
        }()
        r := bufio.NewReader(f)
        b := make([]byte, 3)
        for {
            n, err := r.Read(b)
            if err != nil {
                fmt.Println("Error reading file:", err)
                break
            }
            fmt.Println(string(b[0:n]))
        }
    }
    ```
    
- Write Files
    
    ```go
    func main() {  
        f, err := os.Create("test.txt")
        if err != nil {
            fmt.Println(err)
            return
        }
        l, err := f.WriteString("Hello World")
        if err != nil {
            fmt.Println(err)
            f.Close()
            return
        }
        fmt.Println(l, "bytes written successfully")
        err = f.Close()
        if err != nil {
            fmt.Println(err)
            return
        }
    }
    
    // Concurrent file writing
    func produce(data chan int, wg *sync.WaitGroup) {  
        n := rand.Intn(999)
        data <- n
        wg.Done()
    }
    
    func consume(data chan int, done chan bool) {  
        f, err := os.Create("concurrent")
        if err != nil {
            fmt.Println(err)
            return
        }
        for d := range data {
            _, err = fmt.Fprintln(f, d)
            if err != nil {
                fmt.Println(err)
                f.Close()
                done <- false
                return
            }
        }
        err = f.Close()
        if err != nil {
            fmt.Println(err)
            done <- false
            return
        }
        done <- true
    }
    
    func main() {  
        data := make(chan int)
        done := make(chan bool)
        wg := sync.WaitGroup{}
        for i := 0; i < 100; i++ {
            wg.Add(1)
            go produce(data, &wg)
        }
        go consume(data, done)
        go func() {
            wg.Wait()
            close(data)
        }()
        d := <-done
        if d == true {
            fmt.Println("File written successfully")
        } else {
            fmt.Println("File writing failed")
        }
    }
    ```
    
- JSON
    
    ```go
    /*
    	[]byte, err := json.Marshal(structVar) : Bir struct değişkenini json'a
    																					 parse eder, çevirir. Geriye bir byte
    																					 dizisi döner.
    	json.Unmarshal(jsonBytes, &targetStruct): Bir json'ı struct'a parse eder. Geriye
    																						sadece bir hata döner.  
    */
    goldZone:=Game{
      5555,
      "Mohani Gezegeni Görevi",
      []Player{
          Player{100,"deli","cevat",10.90},
          Player{102,"nadya","komenaççi",12.45},
          Player{103,"biricit","bardot",900.45},
      },
    }   
    
    jsonOutput,_:=json.Marshal(goldZone)
    fmt.Println(string(jsonOutput))
    
    var game Game   
    if err := json.Unmarshal(jsonOutput,&game); err != nil {
          panic(err)
      }
    
    fmt.Printf("Game : %s\n",game.Name)
    
    /*
    	Struct'taki JSON alanlarına 'json tag' denir.
    	Eğer bir json tag'da "-" işareti varsa bu işaret atılır, yok sayılır.
    	"omitempty" ifadesi, yazılan json tag'ının parse edilecek olan json'a çıktı
    	vermemesini sağlar
    
    type Server struct {
        ServerName string `json:"serverName"`
        ServerIP   string `json:"serverIP"`
    }
    
    type Serverslice struct {
        Servers []Server `json:"servers"`
    }
    ```
    
- Time
    
    ```go
    func main() {
        p := fmt.Println
    
        now := time.Now()
        p(now)
    
        then := time.Date(
            2009, 11, 17, 20, 34, 58, 651387237, time.UTC)
        p(then)
    
        p(then.Year())
        p(then.Month())
        p(then.Day())
        p(then.Hour())
        p(then.Minute())
        p(then.Second())
        p(then.Nanosecond())
        p(then.Location())
    
        p(then.Weekday())
    
        p(then.Before(now))
        p(then.After(now))
        p(then.Equal(now))
    
        diff := now.Sub(then)
        p(diff)
    
        p(diff.Hours())
        p(diff.Minutes())
        p(diff.Seconds())
        p(diff.Nanoseconds())
    
        p(then.Add(diff))
        p(then.Add(-diff))
    }
    /* result:
    	2012-10-31 15:50:13.793654 +0000 UTC
    	2009-11-17 20:34:58.651387237 +0000 UTC
    	2009
    	November
    	17
    	20
    	34
    	58
    	651387237
    	UTC
    	Tuesday
    	true
    	false
    	false
    	25891h15m15.142266763s
    	25891.25420618521
    	1.5534752523711128e+06
    	9.320851514226677e+07
    	93208515142266763
    	2012-10-31 15:50:13.793654 +0000 UTC
    	2006-12-05 01:19:43.509120474 +0000 UTC
    */
    ```
    
- URL Parsing
    
    ```go
    func main() {
    
        s := "postgres://user:pass@host.com:5432/path?k=v#f"
    
        u, err := url.Parse(s)
        if err != nil {
            panic(err)
        }
    
        fmt.Println(u.Scheme)
    
        fmt.Println(u.User)
        fmt.Println(u.User.Username())
        p, _ := u.User.Password()
        fmt.Println(p)
    
        fmt.Println(u.Host)
        host, port, _ := net.SplitHostPort(u.Host)
        fmt.Println(host)
        fmt.Println(port)
    
        fmt.Println(u.Path)
        fmt.Println(u.Fragment)
    
        fmt.Println(u.RawQuery)
        m, _ := url.ParseQuery(u.RawQuery)
        fmt.Println(m)
        fmt.Println(m["k"][0])
    }
    
    /* result:
    	postgres
    	user:pass
    	user
    	pass
    	host.com:5432
    	host.com
    	5432
    	/path
    	f
    	k=v
    	map[k:[v]]
    	vpostgres
    	user:pass
    	user
    	pass
    	host.com:5432
    	host.com
    	5432
    	/path
    	f
    	k=v
    	map[k:[v]]
    	v
    */
    ```
    
- Command Line Arguments
    
    ```go
    func main() {
    
        argsWithProg := os.Args
        argsWithoutProg := os.Args[1:]
    
        arg := os.Args[3]
    
        fmt.Println(argsWithProg)
        fmt.Println(argsWithoutProg)
        fmt.Println(arg)
    }
    /* result:
    	go build main.go
    		./command-line-arguments a b c d
    			[./command-line-arguments a b c d]       
    			[a b c d]
    			c
    */
    ```
    
- Environment Variable
    
    ```go
    func main() {
    
        os.Setenv("FOO", "1")
        fmt.Println("FOO:", os.Getenv("FOO"))
        fmt.Println("BAR:", os.Getenv("BAR"))
    
        fmt.Println()
        for _, e := range os.Environ() {
            pair := strings.SplitN(e, "=", 2)
            fmt.Println(pair[0])
        }
    }
    /*
    $ go run environment-variables.go
    	FOO: 1
    	BAR: 
    	..
    	TERM_PROGRAM
    	PATH
    	SHELL
    
    $ BAR=2 go run environment-variables.go
    	FOO: 1
    	BAR: 2
    */
    ```
    
- Context
    
    ```go
    /*
    	İptal sinyallerini taşıyan ve içerisine veri gömülebilen bir veri tipidir.
    	Örneğin bir veritabanına bir istek atıyoruz. Bu istek eğer 3 saniyeyi aşarsa
    	isteğin iptal edilmesini sağlayabiliyoruz.
    */
    
    /* Context yapısı:
    	type Context interface {
    		// Done metodu, context tamamlandığında veya zaman aşımına uğradığında
      	// kapanan bir channel döndürür.
        Done() <-chan struct{}
    
      	// Err metodu, context'in neden kapandığını anlatan bir error döndürür.
        // Genellikle Done kanalı kapandıktan sonra bunu kullanırız.
        Err() error
    
        // Deadline metodu, eğer context herhangi bir deadline'a sahipse deadline
    		zamanını döndürür.
        // `ok` değeri context bir deadline'a sahipse true, değilse false olur.
        Deadline() (deadline time.Time, ok bool)
    
        // Value metodu, context'in içerisinde saklanan bilgilere ulaşmak için
    		kullanılır
        Value(key interface{}) interface{}
    }
    */
    
    /*
    	ctx, cancel := context.Background() boş bir context oluşturur. Diğer context'ler
    	için temel bir context'tir.
    
    	ctx, cancel := context.TODO() boş bir context oluşturur. Ancak ileride bu
    	context'in kullanılacağından emin değilsek kullanılır.
    
    	cancel := Context.WithCancel(context.Background()) geriye bir cancel metodu döner
    	ve çağrıldığı anda context iptal olur.
    	ctx, cancel :=:context.WithDeadline(context.Background(),
    																			time.Now().Add(2 * time.Second))
    	bitiş zamanı verldiğinde context'i bu zamanda iptal eder. Mnual olarak da iptal
    	edilebilir.
    	ctx, cancel :=:context.WithTimeout(context.Background(),
    																			time.Millisecond*time.Duration(150)), verilen
    	süre dolduğunda context'i iptal eder. Manual olarak da iptal edilebilir.
    
    	Genellikle case-select yapısı ile kullanılır. Case'lerden biri ctx.Done()'dır.
    	Eğer ctx.Done() diğer case'lerden önce bir değer dönerse yani context
    	elle cancel() edilirse ya da zamanı dolduğu için biterse bu case çalışır.
    	Böylece diğer case'ler iptal olmuş olur.
    	
    */
    
    ```
    
- Web
    - Form Fields
        
        ```html
        <html>
            <head>
            <title></title>
            </head>
            <body>
                <form action="/login" method="post">
                    Username:<input type="text" name="username">
                    Password:<input type="password" name="password">
                    <input type="submit" value="Login">
                </form>
            </body>
        </html>
        ```
        
        ```go
        import (
            "fmt"
            "html/template"
            "log"
            "net/http"
            "strings"
        )
        
        func sayhelloName(w http.ResponseWriter, r *http.Request) {
            r.ParseForm() //Parse url parameters passed, then parse the response packet for the POST body (request body)
            // attention: If you do not call ParseForm method, the following data can not be obtained form
            fmt.Println(r.Form) // print information on server side.
            fmt.Println("path", r.URL.Path)
            fmt.Println("scheme", r.URL.Scheme)
            fmt.Println(r.Form["url_long"])
            for k, v := range r.Form {
                fmt.Println("key:", k)
                fmt.Println("val:", strings.Join(v, ""))
            }
            fmt.Fprintf(w, "Hello astaxie!") // write data to response
        }
        
        func login(w http.ResponseWriter, r *http.Request) {
            fmt.Println("method:", r.Method) //get request method
            if r.Method == "GET" {
                t, _ := template.ParseFiles("login.gtpl")
                t.Execute(w, nil)
            } else {
                r.ParseForm()
                // logic part of log in
                fmt.Println("username:", r.Form["username"])
                fmt.Println("password:", r.Form["password"])
            }
        }
        
        func main() {
            http.HandleFunc("/", sayhelloName) // setting router rule
            http.HandleFunc("/login", login)
            err := http.ListenAndServe(":9090", nil) // setting listening port
            if err != nil {
                log.Fatal("ListenAndServe: ", err)
            }
        }
        ```
        
        ```go
        		v := url.Values{}
            v.Set("name", "Ava")
            v.Add("friend", "Jess")
            v.Add("friend", "Sarah")
            v.Add("friend", "Zoe")
            // v.Encode() == "name=Ava&friend=Jess&friend=Sarah&friend=Zoe"
            fmt.Println(v.Get("name"))
            fmt.Println(v.Get("friend"))
            fmt.Println(v["friend"])
        ```
        
        <aside>
        💡 r.ParseForm() yerine r.FormValue(”name”) ile de parse edilmeden değer alınabilir.
        
        </aside>
        
        <aside>
        💡 Eğer aynı isme sahip birden fazla değer varsa bunlar slice şeklinde geçer.
        
        </aside>
        
    - XSS (Cross Site Scripting)
        
        ```go
        /*
        	Örneğin input alanlarına js komutları yazılması gibi kötü niyetli işlemlerin
        	yapılmasını engelleyebiliriz. Bunun için server'a gelen HTML kodları herhangi
        	bir html tag'ı ya da js komutu içeriyorsa engellenir. Bunun için Escape fonk-
        	siyonları vardır.
        */
        
        // Client tarafından gelen veri string'e çevilirip özel karakterlerden kaçılır.
        func HTMLEscapeString(s string) string
        
        // Client'a gidecek olan byte'lardaki özel karakterlerden kaçıp öyle client'a
        // gelir.
        func HTMLEscape(w io.Writer, b []byte)
        
        // ExecuteTemplate ile client'a script çalıştırılabilir:
        err = t.ExecuteTemplate(out, "T", "<script>alert('you have ever...?')</script>")
        ```
        
    - File Uploading
        
        ```html
        <html>
        <head>
               <title>Upload file</title>
        </head>
        <body>
        <form enctype="multipart/form-data" action="http://127.0.0.1:9090/upload" method="post">
            <input type="file" name="uploadfile" />
            <input type="hidden" name="token" value="{{.}}"/>
            <input type="submit" value="upload" />
        </form>
        </body>
        </html>
        ```
        
        ```go
        type FileHeader struct {
               Filename string
               Header   textproto.MIMEHeader
               // contains filtered or unexported fields
        }
        
        import (
            "bytes"
            "fmt"
            "io"
            "io/ioutil"
            "mime/multipart"
            "net/http"
            "os"
        )
        
        http.HandleFunc("/upload", upload)
        
        // upload logic
        func upload(w http.ResponseWriter, r *http.Request) {
               fmt.Println("method:", r.Method)
               if r.Method == "GET" {
                   crutime := time.Now().Unix()
                   h := md5.New()
                   io.WriteString(h, strconv.FormatInt(crutime, 10))
                   token := fmt.Sprintf("%x", h.Sum(nil))
        
                   t, _ := template.ParseFiles("upload.gtpl")
                   t.Execute(w, token)
               } else {
                   r.ParseMultipartForm(32 << 20)
                   file, handler, err := r.FormFile("uploadfile")
                   if err != nil {
                       fmt.Println(err)
                       return
                   }
                   defer file.Close()
                   fmt.Fprintf(w, "%v", handler.Header)
                   f, err := os.OpenFile("./test/"+handler.Filename, os.O_WRONLY|os.O_CREATE, 0666)
                   if err != nil {
                       fmt.Println(err)
                       return
                   }
                   defer f.Close()
                   io.Copy(f, file)
               }
        }
        
        func postFile(filename string, targetUrl string) error {
            bodyBuf := &bytes.Buffer{}
            bodyWriter := multipart.NewWriter(bodyBuf)
        
            // this step is very important
            fileWriter, err := bodyWriter.CreateFormFile("uploadfile", filename)
            if err != nil {
                fmt.Println("error writing to buffer")
                return err
            }
        
            // open file handle
            fh, err := os.Open(filename)
            if err != nil {
                fmt.Println("error opening file")
                return err
            }
            defer fh.Close()
        
            //iocopy
            _, err = io.Copy(fileWriter, fh)
            if err != nil {
                return err
            }
        
            contentType := bodyWriter.FormDataContentType()
            bodyWriter.Close()
        
            resp, err := http.Post(targetUrl, contentType, bodyBuf)
            if err != nil {
                return err
            }
            defer resp.Body.Close()
            resp_body, err := ioutil.ReadAll(resp.Body)
            if err != nil {
                return err
            }
            fmt.Println(resp.Status)
            fmt.Println(string(resp_body))
            return nil
        }
        
        // sample usage
        func main() {
            target_url := "http://localhost:9090/upload"
            filename := "./astaxie.pdf"
            postFile(filename, target_url)
        }
        ```
        
    - Session & Cookies
        
        ```go
        /*
        	 HTTP, durumsuz olduğundan bilgilerin client ve server arasında taşınabilmesi
        	için session ve cookie kullanılır.
        	Session, mevcut oturum kapanana kadar isteklerde kullanılır.
        	Ancak cookies, ister süresiz ya da süreli olarak bilgilerin istekler arasında
        	taşınmasını sağlar.
        */
        
        // Cookie Set Etme: http.SetCookie(w ResponseWriter, cookie *Cookie)
        expiration := time.Now().Add(365 * 24 * time.Hour)
        cookie := http.Cookie{Name: "username", Value: "astaxie", Expires: expiration}
        http.SetCookie(w, &cookie)
        
        // Cookie Get
        cookie, _ := r.Cookie("username")
        fmt.Fprint(w, cookie)
        
        // alternative to above
        for _, cookie := range r.Cookies() {
        		fmt.Fprint(w, cookie.Name)
        }
        
        /*
        	Session server tarafında kaydedilirken cookie daha çok client tarafı ile
        	ilgilidir. Bu yüzden cookie'lerde kritik bilgiler tutmak iyi değildir.
        */
        
        // Bir cookie struct'ının içeriği
        	type Cookie struct {
          Name       string
          Value      string
          Path       string
          Domain     string
          Expires    time.Time
        	RawExpires string
        
        // MaxAge=0 means no 'Max-Age' attribute specified.
        // MaxAge<0 means delete cookie now, equivalently 'Max-Age: 0'
        	// MaxAge>0 means Max-Age attribute present and given in seconds
        	MaxAge   int
        	Secure   bool
        	HttpOnly bool
        	Raw      string
        	Unparsed []string // Raw text of unparsed attribute-value pairs
        }
        ```
        
        ```go
        /*
        	Session'lar, Cookie'lerin Expire süresi 0 olarak ayarlanarak oluşturulur.
        	Client'e bir kez gönderilir ve client bunu alır. Bu bilgi client'ın elinden
        	gidene kadar kullanılabilirdir.
        */
        ```