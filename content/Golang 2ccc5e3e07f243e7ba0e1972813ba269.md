# Golang

- Types
    - Golang, tipin Ã§ok Ã¶nemli olduÄŸu bir dildir.
    - Tipsiz sabitler:  KullanÄ±ldÄ±ÄŸÄ± baÄŸlama gÃ¶re tip alÄ±r. VarsayÄ±lan olarak, verilen deÄŸerin tipine gÃ¶re tip alÄ±r. KullanÄ±ldÄ±ÄŸÄ± yerde bir tip type conversion yapÄ±lÄ±r.
    
    ```go
    const degisken = 10
    fmt.Printf("%T, %v", degisken, degisken)
    // int64, 10
    
    fmt.Printf("%t, Tv", (degisken +3.4), (degisken+3.4))
    // float64, 13.4
    ```
    
    - Ä°ÅŸlemler iÃ§in tiplerin aynÄ± olmasÄ± gerekir. int64 ve int32 dahi aynÄ± deÄŸildir
    - string ve int toplanamaz
    - string direk sayÄ±ya ya da sayÄ± direk stringâ€™e cast edilemez Bunun iÃ§in Atoi- itoa kullanÄ±lÄ±r.
    - Type dÃ¶nÃ¼ÅŸÃ¼mÃ¼, adÄ± tipi olan bir fonksiyon ile yapÄ±lÄ±r
    
    ```go
    degisken := 3.4
    degisken2 := int8(degisken)
    // degisken2 = 3
    ```
    
- Scope
    
    Statik kapsamlÄ± bir dildir. Text bazlÄ± olarak kapsamlarÄ± tespit eder. JS gibi fonksiyonun Ã§aÄŸrÄ±ldÄ±ÄŸÄ± yerdeki ebeveyn fonksiyonun ortamÄ±nÄ± kullanamaz.
    
- If Else
    - IF statementâ€™Ä±nde atama iÅŸlemi yapÄ±labilir ve bu iÅŸlem sadece blokta geÃ§erli olacaktÄ±r
    
    ```go
    if i:=5; i<10 {
    	// ....
    }
    ```
    
    - Else bloÄŸunun baÅŸlangÄ±cÄ± yani else keywordâ€™Ã¼, if ya da else-if bloÄŸunu bitiÅŸ sÃ¼slÃ¼ parantezi ile aynÄ± satÄ±rda olmalÄ±dÄ±r yoksa hata verecektir.
    
    ```go
    // YanlÄ±ÅŸ
    if x>5 {
    	// ...
    }
    else {
    	// ....
    }
    
    // DoÄŸru
    if x>5 {
    	// ...
    } else {
    	// ....
    }
    ```
    
    GOâ€™nun yapÄ±sÄ± gereÄŸi return deÄŸeri olan fonksiyonlarda elseâ€™lerden kaÃ§Ä±nÄ±lmalÄ±dÄ±r. IFâ€™in iÃ§inde return verilmelidir. If koÅŸulu saÄŸlanmadÄ±ÄŸÄ±nda zaten direkt koÅŸul dÄ±ÅŸÄ±na Ã§Ä±kacaÄŸÄ± iÃ§in else bloÄŸuna gerek yoktur. Hatta sadece fonksiyonlarda deÄŸil bÃ¼tÃ¼n GO dilinde elseâ€™lere Ã§ok da gerek yokturğŸ™‚
    
    ```go
    // YanlÄ±ÅŸ
    if num := 10; num % 2 == 0 {
        fmt.Println(num,"is even") 
    }  else {
        fmt.Println(num,"is odd")
    }
    
    // DoÄŸru
    if num := 10; num%2 == 0 {
        fmt.Println(num, "is even")
        return
        }
        fmt.Println(num, "is odd")
    ```
    
- Blank Identifier
    
    Bir deÄŸiÅŸkeni tanÄ±mladÄ±k ama kullanmak istemiyoruz. Mesela fonksiyon bir hata deÄŸeri return ediyordur ama biz bu deÄŸeri kullanmak istemiyoruz. Ancak GOâ€™nun gereÄŸi hatayÄ± bir deÄŸiÅŸkene atamalÄ±yÄ±z. Ä°ÅŸte burada blank identifier iÅŸin iÃ§ine giriyor. Daha sonra kullanmak istemeeyceÄŸimiz deÄŸiÅŸenin yerine â€œ_â€(alt Ã§zigi) koyuyoruz. 
    
    ```go
    reader := bufio.NewReader(os.Stdin)
    val, _ := reader.ReadString('\n')
    // Read metodundan dÃ¶nen hatayÄ± bir daha kullanmayacÄŸÄ±mÄ±z iÃ§in blank identifier
    // kullandÄ±k
    ```
    
- Quotes
    - Single quote: Tek bir karakter ya da sadece bir kaÃ§Ä±ÅŸ karakteri(\n) barÄ±ndÄ±ran ifadelerde kullanÄ±lÄ±r.
    - Double quote: Bir string veya metni yazmak iÃ§in kullanÄ±lÄ±r.
    - Back-tick: Bir stringâ€™i yazar. Ancak kaÃ§Ä±ÅŸ ifadelerini de salt string olarak yazar. Ã–rneÄŸin â€œ\tâ€ ifadesini gÃ¶rdÃ¼ÄŸÃ¼nde boÅŸluk bÄ±rakmak yerine bunu yalnÄ±zca â€œ\tâ€ stringi olarak algÄ±layacaktÄ±r.
    
    ```go
    variable := '\n'
    myString := "Muhammed Said TAYLAN"
    ```
    
- Functions
    
    ```go
    /*
    	FonksiyonlarÄ±n parametrelerinin tipleri aynÄ± ise en saÄŸdaki parametreden sonra
    	tip belirtmek yeterlidir. Soldakiler iÃ§in de aynÄ± tip geÃ§erli olacaktÄ±r. veya her 
    	parametre iÃ§in herbirinin yanÄ±na tipi de yazÄ±labilir.
    	Fonksiyonun dÃ¶nÃ¼ÅŸ tipi, parantezlerin dÄ±ÅŸÄ±na yazÄ±lÄ±r. Ä°leride gÃ¶rÃ¼leceÄŸi Ã¼zere
    	eÄŸer birden fazla dÃ¶nÃ¼ÅŸ tipi varsa bunlar da paranteze alÄ±nabilir.
    */
    fmt.Println(myFunc(3, 5))
    
    func myFunc(x, y int) int {
    	return x+y
    }
    ```
    
    ```go
    /*
    	Bir fonksiyondan, birden fazla deÄŸer dÃ¶nebilir. Bunun iÃ§in her dÃ¶nen deÄŸer iÃ§in
    	tip belirtilmelidir.
    	Return deÄŸerlerinin ismi olmak zorunda deÄŸildir. EÄŸer return isminde bir
    	deÄŸiÅŸken bildirilirse returnâ€™de hangi deÄŸiÅŸkenlerin return edileceÄŸini tekrar
    	belirtmeye gerek yoktur. AÅŸaÄŸÄ±daki iki kod da geÃ§erlidir.
    */
    
    bolum, kalan := bol(104, 5)
    
    func bol(bolunen, bolen int) (bolum, kalan int) {
    	return bolunen/bolen, bolunen%bolen
    }
    
    // alternative to above
    func bol(bolunen, bolen int) (bolum, kalan int) {
    	bolum := bolunen/bolen
    	kalan := bolunen % bolen
    	return
    }
    
    func bol(bolunen, bolen int) (int, int) {
    	return bolunen/bolen, bolunen%bolen
    }
    ```
    
- Errors
    
    ```go
    /*
    	Hatalar genellikle fonksiyonlarÄ±n son parametresi olara tanÄ±mlanÄ±r. DiÄŸer dillerin
    	aksine exception olaylarÄ± yoktur. Bir hata tipi vardÄ±r ve bu hata tipinde hata
    	deÄŸiÅŸkenleri oluÅŸturulur. erros.New() ifadesi ile custom hatalar oluÅŸturulabilir.
    */
    import (
    // ...
    "errors"
    )
    
    func main() {
    	bolum, kalan, err := bol(104, 5)
    	if err != nil {
    		fmt.Print(err)
    	}
    	fmt.Println(bolum, kalan)
    }
    
    func bol(bolunen, bolen int) (bolum, kalan int, err error) {
    	if bolunen <= 0 {
    		return 0, 0, errors.New("fonksiyonumuz gereÄŸi negatif sayÄ±larÄ± bÃ¶lemezsiniz :)")
    	}
    	return bolunen / bolen, bolunen % bolen, nil
    }
    
    /*
    	errors.New yerine fmt.Errorf() de kullanÄ±labilir. Printf de olduÄŸu gibi kullanÄ±lÄ±r
    */
    func main() {
    	bolum, kalan, err := bol(104, 5)
    	if err != nil {
    		fmt.Print(err)
    	}
    	fmt.Println(bolum, kalan)
    }
    
    func bol(bolunen, bolen int) (bolum, kalan int, err error) {
    	if bolunen <= 0 {
    		return 0, 0,
    		fmt.Errorf("fonksiyonumuz gereÄŸi negatif sayÄ±larÄ±(%v) bÃ¶lemezsiniz :)", bolunen)
    	}
    	return bolunen / bolen, bolunen % bolen, nil
    }
    ```
    
- ***nil*** Expression
    
    GOâ€™da â€œnilâ€ ifadesi; slice, array, channel gibi complex veri tiplerinin zero-value(baÅŸlangÄ±Ã§ deÄŸeri)â€™larÄ±dÄ±r.
    
- Packages and Go Install & Build
    
    DÄ±ÅŸa aÃ§Ä±k olacak paketlerdeki, diÄŸer paketler tarafÄ±ndan kullanÄ±lacak olan fonksiyon, struct, deÄŸiÅŸkenler... bÃ¼yÃ¼k harfle baÅŸlar. 
    
    Paketler ÅŸu ÅŸekilde oluÅŸturulur. 
    
    ```go
    /* 
    	Proje klasÃ¶rÃ¼mÃ¼zde go.mod dosyasÄ± oluÅŸturup projemizin ana modÃ¼lÃ¼ne bir isim
    	veririz
    
    	// go.mod
    		package firstModule
    
    	Proje klasÃ¶rÃ¼nÃ¼n iÃ§inde bir paket iÃ§in bir klasÃ¶r oluÅŸturduÄŸumuzda bu paket ÅŸu
    	ÅŸekilde gÃ¶rÃ¼ntÃ¼lenir:
    
    	alt paketimiz server olsun.
    		import firstModule/server
    */
    ```
    
    - Go install, aynen go build gibi executable bir dosya oluÅŸturur ancak bu oluÅŸturduÄŸu dosyayÄ± /bin klasÃ¶rÃ¼ne taÅŸÄ±r ve baÄŸÄ±mlÄ±lÄ±klarÄ±nÄ± /pkg klasÃ¶rÃ¼ne taÅŸÄ±r.
- For Loop
    
    For dÃ¶ngÃ¼sÃ¼, while gibi ÅŸartlÄ± olarak da oluÅŸturulabilir. 
    
    ```go
    i:= 0
    for i< 100 {
    // ...
    	i++
    }
    
    for ;i<100;i++ {
    	
    }
    ```
    
- Switch - Case
    
    YazÄ±lan bir case bir daha yazÄ±lamaz. Goâ€™da defaut olarak Break ifadesi her case sonunda kendiliÄŸinden saÄŸlanÄ±r. Bu yÃ¼zden break yazmak uyarÄ±ya neden olacaktÄ±r.
    
    ```go
    switch status {
    	case 'a': 
    	case 'b':
    	default:
    }
    // Case bitiÅŸlerinde 'break' ifadesine gerek yoktur. 
    // Default kullanÄ±labilir.
    
    // Bir case iÃ§inde birden fazla expression yazÄ±lacaksa bunlar virgÃ¼lle ayrÄ±lÄ±r.
    switch status {
    	case 'a': 
    	case 'b', 'c', 'd':
    	default:
    }
    
    // Expression olmadan da switch yazÄ±labilir.
    		num := 75
        switch { // expression is omitted
        case num >= 0 && num <= 50:
            fmt.Printf("%d is greater than 0 and less than 50", num)
        case num >= 51 && num <= 100:
            fmt.Printf("%d is greater than 51 and less than 100", num)
        case num >= 101:
            fmt.Printf("%d is greater than 100", num)
        }
    
    // Fallthrough, ilk girilen case doÄŸru ya da yanlÄ±ÅŸ dahi olsa case'lerin hepsini
    // gezer ve ÅŸartlarÄ± eÅŸleÅŸen case'leri Ã§alÄ±ÅŸtÄ±rÄ±r.
    // AÅŸaÄŸÄ±da 75 hem 51'den hem 52 den bÃ¼yÃ¼k olduÄŸu iÃ§in iki case de Ã§alÄ±ÅŸtÄ±
    num := 75
    	switch { // expression is omitted
    	case num >= 0 && num <= 50:
    		fmt.Printf("%d is greater than 0 and less than 50", num)
    	case num >= 51 && num <= 100:
    		fmt.Printf("%d is greater than 51 and less than 100", num)
    	case num >= 52 && num <= 120:
    		fmt.Printf("%d is greater than 52 and less than 120", num)
    	case num >= 101:
    		fmt.Printf("%d is greater than 100", num)
    	}
    
    // 75 is greater than 51 and less than 100
    // 75 is greater than 52 and less than 120
    
    // EÄŸer bir dÃ¶ngÃ¼ iÃ§inde switch-case kullanÄ±yorsak ve bir case Ã§alÄ±ÅŸtÄ±ÄŸÄ±nda dÃ¶ngÃ¼nÃ¼n
    // sonlanmasÄ±nÄ± istiyorsak 'break label' kullanÄ±lmalÄ±dÄ±r.
    randloop:  
        for {
            switch i := rand.Intn(100); {
            case i%2 == 0:
                fmt.Printf("Generated even number %d", i)
                break randloop
            }
        }
    ```
    
- Arrays
    
    ```go
    // dizinin kaÃ§ elemandan oluÅŸacaÄŸÄ± biliniyorsa
    cities := [4]string{"istanbul", "ankara", "roma", "kudÃ¼s"}
    
    // initialize edilmemiÅŸ bir dizi oluÅŸturur. Her elemanÄ±n zero-value'si vardÄ±r.
    // Bu durumda 0'dÄ±r.
    var myArray [5]int
    
    // dizinin kaÃ§ elemandan oluÅŸacaÄŸÄ± biliniyorsa uzunluÄŸunu belirtmeye gerek yoktur.
    // ÃœÃ§ nokta, dizide kaÃ§ eleman olduÄŸunu kendisi tespit edebilir. (compile time'da)
    cities := [...]string{"istanbul", "ankara", "roma", "kudÃ¼s"}
    
    // dizini tÃ¼m elemanlarÄ±nÄ± yazmaya gerek yoktur. YazÄ±lmayanlar zero-value olarak
    // doldurulacaktÄ±r
    cities := [4]string{"kudÃ¼s"}
    // ["kudÃ¼s" "" "" ""]
    
    // BoyutlarÄ± farklÄ± ancak tipleri aynÄ± olan iki dizi karÅŸÄ±laÅŸtÄ±rÄ±ldÄ±ÄŸÄ±nda sonuÃ§
    // false olacaktÄ±r. Yani boyut da bir bakÄ±ma tipe dahildir.
    var arr1 [4]int
    var arr2 [5]int
    isSame := arr1 == arr2 // false
    
    // Diziler, referans tipler deÄŸildir. Yani bir dizi baÅŸka bir deÄŸiÅŸkene atanÄ±rsa
    // dizinin kendisi dedÄŸil yalnÄ±zca iÃ§indeki deÄŸerler geÃ§er. Bir dizide bir deÄŸiÅŸiklik
    // yapÄ±ldÄ±ÄŸÄ±nda diÄŸer dizi bundan etkilenmeyecektir.
    
    // Ã‡ok boyutlu diziler de oluÅŸturulabilir.
    multiArr := [3][4]int{}
    
    // Dizinin boyutu len fonksiyonu ile kontrol edilebilir.
    len(myArray)
    ```
    
- For - Range
    
    Dizinin(collection) elemanlarÄ± Ã¼zerinde dÃ¶nmeye yarar. 
    
    ```go
    cities := [4]string{"istanbul", "ankara", "roma", "kudÃ¼s"}
    
    for index, value := range cities {
    	fmt.Println(index, value)
    }
    
    // alternative
    for _ , value := range cities {
    	fmt.Println(value)
    }
    ```
    
- Slices
    
    Sliceâ€™lar, mevcut dizilere sadece bir referanstÄ±r. Kendi verileri yoktur.
    
    ```go
    // Slice'lar aslÄ±nda aÅŸaÄŸÄ±da gÃ¶rÃ¼leeceÄŸi Ã¼zere dizi parÃ§alarÄ±dÄ±r.
    // Ancak slice'lar diziler gibi 0'dan da oluÅŸturulabilir.
    myArr := [...]int{0, 2 ,4, 6, 8, 10}
    mySlc := myArr[1:5]
    
    // BoÅŸ bir slice bu ÅŸekilde oluÅŸturulabilir ancak uzunluÄŸu bilinmediÄŸi iÃ§in iÃ§inde
    // herhangi bir deÄŸer yoktur. Bu yÃ¼zden mySlc[0] = 10 dendiÄŸinde hata verir.
    var mySlc []int
    // []
    
    // Bu ÅŸekilde de bir slice oluÅŸturulup ilk deÄŸerleri verilebilir.
    mySlc := []int{12, 20, 32, 44}
    
    // Slice'ta bir deÄŸiÅŸiklik yapÄ±ldÄ±ÄŸÄ±nda, baÄŸlÄ± olduÄŸu dizi de etkilenir. Ã‡Ã¼nkÃ¼ slice'lar
    // tek baÅŸÄ±na bir ÅŸeye sahip deÄŸildirler. Sadece dizilerin bir referansÄ±dÄ±r.
    myArr := [...]int{29, 31, 33, 35, 37, 39, 41}
    mySlc := myArr[1:5]
    mySlc[0]++
    fmt.Print(mySlc) // [29, 32, 33, 35, 37, 39, 41]
    mySlc2 := myArr[:] // bu durumda dizinin elamanlarÄ±nÄ±n tamamÄ±ndan bir slice 
    // oluÅŸturulacak ama bu slice'da diziye referans olacak. DeÄŸiÅŸiklikler diziyi de etkiler
    
    myArr := [...]int{29, 31, 33, 35, 37, 39, 41}
    mySlc := myArr[1:5]
    // bu slice'Ä±n kapasitesi 6'dÄ±r. Kapasite, slie'Ä±n start index'inden slice yapÄ±lan
    // dizinin son elemanÄ±na kadardÄ±r. Yani 1. index'ten sona kadar.
    
    // make fonksiyonu ile slice oluÅŸturulabilir.
    // ilk parametre tipi, ikinci parametre slice boyutu, Ã¼Ã§Ã¼ncÃ¼ parametre(isteÄŸe baÄŸlÄ±) ise
    // slice'Ä±n kapasitesidir. Kapasite boyuttan kÃ¼Ã§Ã¼k olamaz.
    mySlc := make([]int, 5, 10)
    
    // slice'lara eleman eklenebilir.
    mySlc := make([]int, 5)
    mySlc = append(mySlc, 3,3,3)
    
    // slice'lardan eleman silerken gerekli yerlerin alt slice'larÄ±nÄ± alÄ±rÄ±z.
    mySlc := []int{0,2,4,6,8,10}
    mySlc = mySlc[:len(mySlc)-3]
    // slice'Ä±n son iki elemanÄ±nÄ± siler.
    
    mySlc := []int{0,2,4,6,8,10}
    mySlc = mySlc[2:]
    //slice'Ä±n ilk iki elemanÄ±nÄ± siler
    
    mySlc := []int{0,2,4,6,8,10}
    mySlc = append(mySlc[:2], mySlc[3:])
    // slice'Ä±n 2. index'ini siler.
    
    // Slice'lar referans veri tipleri olduÄŸundan, bir fonksiyona argÃ¼man olarak
    // geÃ§tiklerinde adresleri geÃ§er. Yani fonksiyonda yapÄ±lan bir deÄŸiÅŸiklik orijinal
    // slice'Ä± da etkileyecektir.
    ```
    
- Maps
    
    Pythonâ€™daki dictionary ile aynÄ±dÄ±r. Ancak tabi statik tiplemeli. ElemanlarÄ±n index deÄŸerleri yoktur.
    
    ```go
    // Key ve value'ler kendi iÃ§ilerinde tipe sahiptir. Key'ler string, value'ler int olacak
    // Her elemandan sonra virgÃ¼l koyulmasÄ± zorunludur.
    grades := map[string]int{
    	"said": 51,
    	"ahmet": 21,
    	"tuÄŸÃ§e": 85,
    	"tuÄŸkan": 0,
    }
    fmt.Println(grades) // map[ahmet:21 said:51 tuÄŸkan:0 tuÄŸÃ§e:85]
    fmt.Println(grades["said"]) // 51
    
    // YazÄ±lan key eÄŸer mapte yoksa geriye, value'nin zero-value'si yani 0 dÃ¶necektir.
    fmt.Println(grades["fatma"]) // 0
    
    // TuÄŸkan'Ä±n deÄŸeri 0. Ama Fatma da mapte olmadÄ±ÄŸÄ± iÃ§in 0 dÃ¶necek. BunlarÄ± nasÄ±l
    // ayÄ±racaÄŸÄ±z?
    value, ok := grades["fatma"] // ok = false, value = 0
    // ok, false ise mapte yok demektir.
    value, ok := grades["tuÄŸkan"] // ok = true, value = 0
    // ok, true ise mapte var demektir.
    
    // make metodu ile de map oluÅŸturulabilir.
    grades := make(map[string]int)
    
    // map'lere eleman eklenip Ã§Ä±kartÄ±labilir.
    grades["GÃ¶ksel"] = 45
    delete(grades, "said")
    
    // map'lerin uzunluÄŸu len fonksiyonu ile bulunabilir.
    len(grades) // 4
    
    // Map'ler referans veri tipidir. Yani bir map'i baÅŸka bir deÄŸiÅŸkene atadÄ±yÄ±p bir deÄŸeri
    // deÄŸiÅŸtirdiÄŸimizde orijinal map de deÄŸiÅŸir.
    
    // Map'lerde for dÃ¶ngÃ¼sÃ¼ ile gezilebilir.
    for k,v := range grades {
    	fmt.Println(k, v)
    }
    
    // Mapin zero-value'si nil'dir.
    
    // Map'ler karÅŸÄ±laÅŸtÄ±rÄ±lamaz. Bir Map ancak nil mi diye karÅŸÄ±laÅŸtÄ±rÄ±labilir.
    
    // InÄ±talize edilmemiÅŸ bir map'e eleman eklenemez.
    ```
    
- String
    
    Byte dizileridir
    
    ```go
    // String Ã¼zerinde de dÃ¶ngÃ¼ ile gezilebilir.
    
    // %s format specifier ile kullanÄ±labilir.
    fmt.Printf("%s", myString)
    
    // %c ile string karakterleri dÃ¶ngÃ¼ ile tek tek yazdÄ±rÄ±larak string yazdÄ±rÄ±labilir.
    
    // Rune tipinde karakterlerin unicode karÅŸÄ±lÄ±klarÄ± ile oluÅŸturulan bir slice ile
    // string oluÅŸturulabilir.
    runeSlice := []rune{0x0053, 0x0065, 0x00f1, 0x006f, 0x0072}
        str := string(runeSlice)
        fmt.Println(str) // SeÃ±or
    
    // string uzunluÄŸu len fonksiyonu ile bulunur
    myString := "Said Taylan"
    len(myString) // 11
    
    // string'lerin eÅŸitliÄŸi == operatÃ¶rÃ¼ ile karÅŸÄ±laÅŸtÄ±rÄ±labilir.
    
    // String birleÅŸtirme
    string1 := "Muhammed Said"
    string2 := "Taylan"
    total := string1 + "" + string2
    
    // Sprintf fonksiyonu formatlanmÄ±ÅŸ bir stringg geri dÃ¶ner.
    formattedString := fmt.Sprintf("%s %s", string1 , string2)
    
    // STringler immutable(deÄŸiÅŸtirlemez) veri tipleri olduÄŸundan string'leri deÄŸiÅŸtirmek
    // iÃ§in string'i Ã¶ncelikle "rune dizisi"ne Ã§evirmek daha sonra Ã¼zerinde deÄŸiÅŸiklik
    // yapmak gerekir.
    func mutate(s []rune) string {
    	s[0] = 'a'
    	return string(s)
    }
    func main() {
    	h := "hello"
    	fmt.Println(mutate([]rune(h)))
    }
    ```
    
- Struct
    
    FarklÄ± veri tiplerini bir arada tutmaya yarayan bir veri tipidir. 
    
    ```go
    var myStruct struct {
    name string,
    lastName string,
    age int8
    children []string
    }
    
    myStruct.name = "Said"
    myStruct.lastName = "Taylan"
    myStruct.age = 21
    myStruct.children = []string{"dilruba", "dilara"}
    // yukarÄ±daki gibi struct'Ä± deÄŸiÅŸken olarak tanÄ±mlamak iyi deÄŸildir ve zaten kullanÄ±lmaz
    
    // struct tip olarak tanÄ±mlanÄ±r ve oluÅŸturulan deÄŸiÅŸkenler bu tipte tanÄ±mlanÄ±r.
    type myStruct struct {
    name string
    lastName string
    age int8
    children []string
    }
    
    var person myStruct = myStruct{
    name: "Said",
    lastName: "Taylan",
    age: 21
    children []string{"dilruba", "dilara"}
    }
    
    // struct alanlarÄ±, isim vermeden de tanÄ±mlama sÄ±rasÄ±na gÃ¶re yazÄ±labilir.
    type Employee struct {  
        firstName, lastName string
        age       int
        salary    int
    }
    emp2 := Employee{"Thomas", "Paul", 29, 800}
    
    fmt.Print(person.name, person.lastName)
    
    // Struct'lar referans veri tÃ¼rleri deÄŸildir JS'nin aksine.
    
    // OOP'taki inheritance kavramÄ±na benzemektedir. Manager, myStruct'tan miras alÄ±r.
    type myStruct struct {
    name string
    lastName string
    age int8
    children []string
    }
    
    type manager struct {
    myStruct myStruct
    department string
    salary int32
    }
    
    man := manager{
    		myStruct: myStruct{
    			name:     "said",
    			lastName: "taylan",
    			age:      25,
    			children: []string{},
    		},
    		department: "IT",
    		salary: 5600,
    	}
    // alternatively
    man := manager{}
    	man.name = "said"
    	man.lastName = "taylan"
    	man.age=21
    	man.children = []string{}
    	man.department = "IT"
    	man.salary = 5600
    
    // Anonymous struct; deÄŸiÅŸken tanÄ±mlama anÄ±nda tanÄ±mlanan struct'tÄ±r.
    boss := struct {
    	name string
    	age int8
    }{"THE BOSS", 55}
    
    // isimsiz alanlar da oluÅŸturulabilir. Tipin adÄ± alan adÄ± olacaktÄ±r. Bu yÃ¼zden bir
    // struct iÃ§inde aynÄ± tipte birden fazla field olamaz.
    type Person struct {  
        string
        int
    }
    
    func main() {  
        p1 := Person{
            string: "naveen",
            int:    50,
        }
        fmt.Println(p1.string)
        fmt.Println(p1.int)
    }
    
    // Struct'larÄ±n ve struct alanlarÄ±nÄ±n ilk harfler bÃ¼yÃ¼k olursa bunlara dÄ±ÅŸ paketlerden
    // eriÅŸilebilir.
    
    // EÄŸer struct'larÄ±n field'larÄ± eÅŸit ise struct'lar eÅŸittir. EÄŸer alanlar 
    // karÄ±ÅŸÄ±laÅŸtÄ±rÄ±labilir ise struct'lar karÅŸÄ±laÅŸtÄ±rÄ±labilirdir. Yani field'lar iÃ§inde
    // map gibi fields'lar varsa struct'lar karÅŸÄ±laÅŸtÄ±rÄ±lamaz. Hata verecektir.
    ```
    
- Methods
    
    Tiplere Ã¶zel fonksiyonlar tanÄ±mlanmasÄ±dÄ±r. Bir nevi OOPâ€™taki metotlar gibi
    
    ```go
    type Employee struct {  
        name     string
        salary   int
        currency string
    }
    
    func (e Employee) displaySalary() {  
        fmt.Printf("Salary of %s is %s%d", e.name, e.currency, e.salary)
    }
    
    func main() {  
        emp1 := Employee {
            name:     "Sam Adolf",
            salary:   5000,
            currency: "$",
        }
        emp1.displaySalary()
    }
    
    // Methods vs Functions
    // Her fonksiyondan yalnÄ±zca bir tane yapÄ±labilir ancak her tip iÃ§in bir metot 
    // yazzÄ±labilir. Ä°kinci olarak ise OOP felsefesini uygulamak iÃ§in bir yaklaÅŸÄ±mdÄ±r.
    // Ve ayrÄ±ca bence daha hoÅŸ gÃ¶zÃ¼kmektedir.
    
    // Tipleri pointer ile gÃ¶ndermek, metot iÃ§inde tipte yapÄ±lacak bir deÄŸiÅŸikliÄŸi
    // tipin kendisine de gerÃ§ekleÅŸtirir.
    /*
    Method with value receiver
    */
    func (e Employee) changeName(newName string) {  
        e.name = newName
    }
    
    /*
    Method with pointer receiver  
    */
    func (e *Employee) changeAge(newAge int) {  
        e.age = newAge
    }
    
    func main() {  
        e := Employee{
            name: "Mark Andrew",
            age:  50,
        }
        fmt.Printf("Employee name before change: %s", e.name)
        e.changeName("Michael Andrew")
        fmt.Printf("\nEmployee name after change: %s", e.name)
    
        fmt.Printf("\n\nEmployee age before change: %d", e.age)
        e.changeAge(51)
        fmt.Printf("\nEmployee age after change: %d", e.age)
    }
    //! Value receiver, aslÄ±nda bir pointer da alabilir.
    
    // Bir nested struct'Ä±n metoduna tip olarak parent struct gÃ¶nderilse de sorunsuz
    // Ã§alÄ±ÅŸacaktÄ±r Ã§Ã¼nkÃ¼ GO bunu kendisi algÄ±layacaktÄ±r.
    type address struct {  
        city  string
        state string
    }
    
    func (a address) fullAddress() {  
        fmt.Printf("Full address: %s, %s", a.city, a.state)
    }
    
    type person struct {  
        firstName string
        lastName  string
        address
    }
    
    func main() {  
        p := person{
            firstName: "Elon",
            lastName:  "Musk",
            address: address {
                city:  "Los Angeles",
                state: "California",
            },
        }
    
        p.fullAddress()
    
    }
    ```
    
- Custom Types
    
    Kendi tiplerimiz oluÅŸturulabilir. En bÃ¼yÃ¼k faydasÄ± tiplere Ã¶zel metotlar oluÅŸturabilmektedir. 
    
    ```go
    type mile float64
    type kilometer float64
    // artÄ±k mile, float64 Ã¶zellikleri gÃ¶steren bir tiptir. Ekstra fonksiyonalite de
    // eklenebilir.
    
    func toKilometer(m mile) kilometer {
    	return mile/1.6
    }
    ```
    
- Reflect
    
    Reflect paketi run-timeâ€™da verilerin ve yapÄ±larÄ±n tiplerini, verilerini, tÃ¼rlerini vesaire saptamaya yarar.
    
    ### Typeof - Valueof
    
    ```go
    package main
    
    import (  
        "fmt"
        "reflect"
    )
    
    type order struct {  
        ordId      int
        customerId int
    }
    
    func createQuery(q interface{}) {  
        t := reflect.TypeOf(q)
        v := reflect.ValueOf(q)
        fmt.Println("Type ", t)
        fmt.Println("Value ", v)
    
    }
    func main() {  
        o := order{
            ordId:      456,
            customerId: 56,
        }
        createQuery(o)
    
    }
    
    // output
    Type  main.order  
    Value  {456 56}
    ```
    
    ### Typeof vs Kind
    
    ```go
    func createQuery(q interface{}) {  
        t := reflect.TypeOf(q)
        k := t.Kind()
        fmt.Println("Type ", t)
        fmt.Println("Kind ", k)
    
    }
    func main() {  
        o := order{
            ordId:      456,
            customerId: 56,
        }
        createQuery(o)
    
    }
    
    // output
    Type  main.order  
    Kind  struct
    ```
    
    ### NumField - Field
    
    ```go
    func createQuery(q interface{}) {  
        if reflect.ValueOf(q).Kind() == reflect.Struct {
            v := reflect.ValueOf(q)
            fmt.Println("Number of fields", v.NumField())
            for i := 0; i < v.NumField(); i++ {
                fmt.Printf("Field:%d type:%T value:%v\n", i, v.Field(i), v.Field(i))
            }
        }
    
    }
    func main() {  
        o := order{
            ordId:      456,
            customerId: 56,
        }
        createQuery(o)
    }
    
    // output
    Number of fields 2  
    Field:0 type:reflect.Value value:456  
    Field:1 type:reflect.Value value:56
    ```
    
- Pointer
    
    ```go
    // Pointerâ€™lerin tipleri de aynÄ± olmalÄ±dÄ±r. String deÄŸerin adresini tutan bir
    // pointerâ€™da int bir deÄŸerin adresi saklanamaz.
    
    // Go'da Pointer bildiÄŸimiz C'deki gibi kullanÄ±lmaktadÄ±r. Sadece veri tipi Ã§ok Ã¶nemli 
    
    // OldukÃ§a bÃ¼yÃ¼k bir dizi, fonksiyona argÃ¼man olarak giderse bu dizinin kopyasÄ±nÄ±nÄ±
    // alÄ±nmasÄ± bÃ¼yÃ¼k bir maliyettir. Bunun iÃ§in bÃ¼yÃ¼k verileri pointer yardÄ±mÄ±yla geÃ§irmek
    // daha mantÄ±klÄ±dÄ±r.
    
    // Pointer'lerin zero-value'si nil'dir.
    
    // new fonksiyonu, kendisine argÃ¼man olarak verilen tipte bir deÄŸiÅŸken oluÅŸturup
    // adresini geri dÃ¶ndÃ¼rÃ¼r.
    newVar := new(int32)
    
    Pointer
    
    x := 5
    change(&x)
    fmt.Print(x) // x: 10
    
    func change(x *int) {
    	*x = 10;
    }
    
    func returnPointer() *int {
    	a := 12+3
    	return &a
    }
    
    // Bir fonksiyona argÃ¼man olarak bir dizinin adresini pointer yardÄ±mÄ±yla geeÃ§irip
    // dizide deÄŸiÅŸiklik yapmak yerine argÃ¼man olarak slice gÃ¶ndermek daha kullanÄ±ÅŸlÄ± bir
    // yoldur ki slice'lar da bu yÃ¼zden vardÄ±r zaten :) 
    func modify(sls []int) {  
        sls[0] = 90
    }
    
    func main() {  
        a := [3]int{89, 90, 91}
        modify(a[:])
        fmt.Println(a)
    }
    
    // Golang, pointer aritmetiÄŸini desteklemez.
    ```
    
- Interface
    
    Normalde .Net tarafÄ±ndaki interface kavramÄ±nÄ± dÃ¼ÅŸÃ¼ndÃ¼ÄŸÃ¼mÃ¼zde nesne yÃ¶nelimli programlama dillerinin temel Ã¶zelliklerinden olan Ã§ok biÃ§imlilik*(Polymorphysm)*Â ve kalÄ±tÄ±mÄ±*(Inheritance)*Â destekleyen bir tip olarak kullanÄ±ldÄ±ÄŸÄ±nÄ± gÃ¶rÃ¼rÃ¼z. Bu aÃ§Ä±dan bakÄ±ldÄ±ÄŸÄ±ndaÂ bir arayÃ¼z iÃ§erisinde onu uygulayan diÄŸer tiplerin sahip olmasÄ± gereken Ã¶zelliklerin ve yapmasÄ±Â gereken aksiyonlarÄ±n tanÄ±mlanmasÄ± sÃ¶z konusudur. Ancak Go, nesne yÃ¶nelimli bir dil deÄŸildir ve interface onun tip sisteminin Ã¶nemli bir karakteristiÄŸini yansÄ±tmaktadÄ±r: Bir tipin hangi verilere sahip olmasÄ± gerektiÄŸinden ziyade hangi aksiyonlarÄ± icra etmesi gerektiÄŸinin soyutlanmasÄ±dÄ±r. Bir fonksiyona ya da herhangi bir yere hangi tipin geleceÄŸinden Ã§ok gelecek tipin uygulayacaÄŸÄ± metotlar Ã¶nemliyse burada interface kullanÄ±labilir. 
    
    ```go
    package main
     
    import (
        "fmt"
        )
         
    func main(){
        actors:=[]Actor{Tank{"T-80",100},Player{"Gun Ball"}}
        for _,a:=range actors{
            a.SaySomething("hello")
            a.Move("left")
        }
    }
     
    type Actor interface{
        Move(direction string)
        SaySomething(speach string)
    }
     
    type Tank struct{
        model string
        power int
    }
    func(t Tank) SaySomething(s string){
        fmt.Printf("'%s' says : %s\n",t.model,s)
    }
    func(t Tank) Move(d string){
        fmt.Printf("'%s' move to %s\n",t.model,d)
    }
     
    type Player struct{
        name string
    }
    func(p Player) Move(d string){
        fmt.Printf("'%s' move to %s\n",p.name,d)
    }
    func(p Player) SaySomething(s string){
        fmt.Printf("'%s' says %s\n",p.name,s)
    }
    
    // main fonksiyonunun iÃ§indeki slice iÃ§inde birden fazla farklÄ± tip var. Bu, interface
    // sayesinde oluyor. Actor, bir interface; ve interface olduÄŸu iÃ§in slice iÃ§inde farklÄ±
    // iki veri tipi kullanÄ±labildi. Bu tipler iÃ§in Ã¶nemli olan ÅŸey kullancaÄŸÄ± metodlar.
    // Ä°ki veri tipinin de kullanacaÄŸÄ± metotlar interface iÃ§inde belirtildiÄŸi iÃ§in ortak
    // yanlarÄ± bu. Interface iÃ§inde tanÄ±mlanmayan bir metot, tip tarafÄ±ndan kullanÄ±lamaz
    // ancak interface'de tanÄ±mlanan metodlar kullanÄ±lmak zorunda deÄŸildir.
    // KÄ±saca interface, tipler iÃ§in kullanÄ±lmasÄ±nÄ± istediÄŸimiz metotlar iÃ§in bize bir ÅŸablon
    // verir.
    
    // AyrÄ±ca bir de interface tip olarak kullanÄ±labilir. Hangi tipin geleceÄŸini
    // kestiremediÄŸimiz parametrelerde interface{} kullanabiliriz. BÃ¶ylece oraya
    // int, float, bool ya da herhangi bir veri tipi gelebilir.
    // Bu interface tipinin iÃ§ine metot yazÄ±lma zorunluluÄŸu da yoktur. Ä°Ã§i boÅŸ olabilir.
    
    // Type Assertion, tipi interface olarak verilmiÅŸ olan deÄŸerin asÄ±l tipine geri
    // dÃ¶ndÃ¼rÃ¼lmesidir.
    package main
    
    import (  
        "fmt"
    )
    
    func assert(i interface{}) {  
        v, ok := i.(int)
    // i ile gelen, tipleri interface olan 56 ve "Steven Paul" argÃ¼manlarÄ±nÄ± int'e 
    // Ã§evirmeyi dener. EÄŸer altta yatan tipi zaten int ise baÅŸarÄ±lÄ± bir ÅŸekilde 
    // Ã§evrilecek ve ok deÄŸiÅŸkeni true olacak. Ancak altta yatan(underlying) tip int
    // deÄŸil ise "ok" deÄŸiÅŸkeni false olacak. 
        fmt.Println(v, ok)
    }
    func main() {  
        var s interface{} = 56
        assert(s)
        var i interface{} = "Steven Paul"
        assert(i)
    }
    
    // Bir fonksiyona interface olarak farklÄ± veri tipleri gelebileceÄŸi iÃ§in bunu 
    // switch-case ile yapmak iyi olacaktÄ±r. 
    func findType(i interface{}) {
    	switch i := i.(type) {
    	case string:
    		fmt.Printf("I am a string and my value is %s\n", i)
    	case int:
    		fmt.Printf("I am an int and my value is %d\n", i)
    	default:
    		fmt.Printf("Unknown type\n")
    	}
    }
    func main() {
    	findType("Naveen")
    }
    
    // ---------------------------------------------------------------
    
    // Pointer olarak tanÄ±mlanmayan bir interface, pass by pointer ile metota geÃ§irilmiÅŸ
    // bir tip ile kullanÄ±lamaz. Yani o tip o interface'ye atanamaz.
    type Describer interface {  
        Describe()
    }
    type Person struct {  
        name string
        age  int
    }
    
    func (p Person) Describe() { //implemented using value receiver  
        fmt.Printf("%s is %d years old\n", p.name, p.age)
    }
    
    type Address struct {  
        state   string
        country string
    }
    
    func (a *Address) Describe() { //implemented using pointer receiver  
        fmt.Printf("State %s Country %s", a.state, a.country)
    }
    
    func main() {  
        var d1 Describer
        p1 := Person{"Sam", 25}
        d1 = p1
        d1.Describe()
        p2 := Person{"James", 32}
        d1 = &p2
        d1.Describe()
    
        var d2 Describer
        a := Address{"Washington", "USA"}
    
        /* compilation error if the following line is
           uncommented
           cannot use a (type Address) as type Describer
           in assignment: Address does not implement
           Describer (Describe method has pointer
           receiver)
        */
        //d2 = a
    
        d2 = &a //This works since Describer interface
        //is implemented by Address pointer in line 22
        d2.Describe()
    
    }
    
    // Interface'nÄ±n zero-value'si nil'dir.
    type Describer interface {  
        Describe()
    }
    
    func main() {  
        var d1 Describer
        if d1 == nil {
            fmt.Printf("d1 is nil and has type %T value %v\n", d1, d1)
        }
    }
    
    // Initialize edilmemiÅŸ yani nil olan bir interface kullanÄ±lmaya Ã§alÄ±ÅŸÄ±lÄ±rsa panic
    // atacaktÄ±r.
    
    // Ã‡oklu interface. Kodda gÃ¶stermek istediÄŸim ÅŸey aslÄ±nda interface'nin tip olarak
    // nasÄ±l kullanÄ±ldÄ±ÄŸÄ±nÄ± gÃ¶stermek
    type SalaryCalculator interface {  
        DisplaySalary()
    }
    
    type LeaveCalculator interface {  
        CalculateLeavesLeft() int
    }
    
    type Employee struct {  
        firstName string
        lastName string
        basicPay int
        pf int
        totalLeaves int
        leavesTaken int
    }
    
    func (e Employee) DisplaySalary() {  
        fmt.Printf("%s %s has salary $%d", e.firstName, e.lastName, (e.basicPay + e.pf))
    }
    
    func (e Employee) CalculateLeavesLeft() int {  
        return e.totalLeaves - e.leavesTaken
    }
    
    func main() {  
        e := Employee {
            firstName: "Naveen",
            lastName: "Ramanathan",
            basicPay: 5000,
            pf: 200,
            totalLeaves: 30,
            leavesTaken: 5,
        }
        var s SalaryCalculator = e
        s.DisplaySalary()
        var l LeaveCalculator = e
        fmt.Println("\nLeaves left =", l.CalculateLeavesLeft())
    }
    // Bir tip oluÅŸturulur ve interface'ye atanÄ±r.
    
    // Birden Ã§ok interface bir interface Ã§atÄ±sÄ± altÄ±nda nested olarak kullanÄ±labilir.
    type SalaryCalculator interface {  
        DisplaySalary()
    }
    
    type LeaveCalculator interface {  
        CalculateLeavesLeft() int
    }
    
    type EmployeeOperations interface {  
        SalaryCalculator
        LeaveCalculator
    }
    
    type Employee struct {  
        firstName string
        lastName string
        basicPay int
        pf int
        totalLeaves int
        leavesTaken int
    }
    
    func (e Employee) DisplaySalary() {  
        fmt.Printf("%s %s has salary $%d", e.firstName, e.lastName, (e.basicPay + e.pf))
    }
    
    func (e Employee) CalculateLeavesLeft() int {  
        return e.totalLeaves - e.leavesTaken
    }
    
    func main() {  
        e := Employee {
            firstName: "Naveen",
            lastName: "Ramanathan",
            basicPay: 5000,
            pf: 200,
            totalLeaves: 30,
            leavesTaken: 5,
        }
        var empOp EmployeeOperations = e
        empOp.DisplaySalary()
        fmt.Println("\nLeaves left =", empOp.CalculateLeavesLeft())
    }
    ```
    
- Variadic Functions
    
    Fonksiyona kaÃ§ argÃ¼man geleceÄŸi bilinemediÄŸi zamanlarda kullanÄ±lÄ±r. Teorik olarak sÄ±nÄ±rsÄ±z sayÄ±da argÃ¼man alabilir. 
    
    ```go
    // myFunc fonksiyonuna birÃ§ok argÃ¼man geÃ§ti. GeÃ§en argÃ¼manlar bir slice ÅŸeklinde geÃ§er.
    func main() {
    	myFunc(true, 4, 5.4, 6, 7, "hello said", 9)
    }
    
    func myFunc(args ...interface{}) {
    	fmt.Printf("%#v", args)
    }
    
    // YalnÄ±zca son parametre variadic olabilir.
    
    // Variadic parametreye 0 argÃ¼man da geÃ§elebilir.
    
    // Bir slice'Ä± thre dot ile variadic argument olarak geÃ§irebiliriz.
    func mySliceFunc(args ...int) {
    	for _, v := range args {
    		fmt.Print(v)
    	}
    }
    theSlice := []int{5,10,15,20,25,30}
    mySliceFunc(theSlice...)
    
    // Bir slice parÃ§alanÄ±p variadic olarak bir fonksiyona geÃ§tiÄŸinde artÄ±k yeni bir slice
    // oluÅŸturulacaÄŸÄ±ndan fonksiyondaki slice'ta yapÄ±lan deÄŸiÅŸiklik ana slice'Ä±
    // etkilemeyecektir.
    ```
    
- Goroutines
    
    Daha az kaynak kullanan ve daha zarif bir thread gibi dÃ¼ÅŸÃ¼nÃ¼lebilir. Bir thread oluÅŸturulduÄŸunda sabit bir boyuta sahiptir ancak goroutineâ€™ler ihtiyaca gÃ¶re daralÄ±p geniÅŸleyebilir. 
    
    ```go
    // Main fonksiyonu da bir goroutine'dir. Goroutine'lerin bitmesini beklemeden biter.
    // DiÄŸer goroutine'ler ile iletiÅŸim kurulmasÄ± lazÄ±m ki goroutine'nin bittiÄŸini anlasÄ±n
    
    package main
    
    import (  
        "fmt"
        "time"
    )
    
    func numbers() {  
        for i := 1; i <= 5; i++ {
            time.Sleep(250 * time.Millisecond)
            fmt.Printf("%d ", i)
        }
    }
    func alphabets() {  
        for i := 'a'; i <= 'e'; i++ {
            time.Sleep(400 * time.Millisecond)
            fmt.Printf("%c ", i)
        }
    }
    func main() {  
        go numbers()
        go alphabets()
        time.Sleep(3000 * time.Millisecond)
        fmt.Println("main terminated")
    }
    
    // Main fonksiyonunun goroutine'leri beklemesini basit bir time iÅŸlevi ile de
    // bekeltebiliriz ancak bu verimsiz bir yoldur ve diÄŸer goroutine'lerin ne zaman 
    // biteceÄŸini her zaman kestiremeyiz. Bu yÃ¼zden Channels kullanÄ±lÄ±r. 
    ```
    
- Channels
    - Temeller ve Unbuffered Channels
        
        ```go
        // Go-routine'ler ile birlikte kullanÄ±lÄ±r.
        // Verinin bir uÃ§tan diÄŸer uca taÅŸÄ±nmasÄ±nÄ± saÄŸlayan yollardÄ±r.
        
        // Zero-value'si nil'dir.
        
        // Initialize edilmemiÅŸ bir channel'de herhangi bir veri taÅŸÄ±namaz.
        // Bu yÃ¼zden channel oluÅŸturmak iÃ§in make fonksiyonu kullanÄ±lÄ±r.
        func main() {  
            var a chan int
            if a == nil {
                fmt.Println("channel a is nil, going to define it")
                a = make(chan int)
                fmt.Printf("Type of a is %T", a)
            }
        }
        
        // TaÅŸÄ±nacak verinin tÃ¼rÃ¼ ile channel tipi aynÄ± olmalÄ±dÄ±r.
        
        // a kanalÄ±ndaki veri okunup data deÄŸiÅŸkenine aktarÄ±lÄ±r.
        // Alttaki satÄ±rda ise datadaki veri a kanalÄ±na giriyor.
        // DÄ±ÅŸa dÃ¶nÃ¼k ok, a'dan veri okunacaÄŸÄ±nÄ±, a'ya dÃ¶nÃ¼k olan ok ise a kanalÄ±na
        // yazÄ±lacaÄŸÄ±nÄ± sÃ¶yler.
        data := <- a // read from channel a  
        a <- data // write to channel a
        
        // Channel'deki veri okunmadan channel'e veri yazÄ±lamaz. Bunun sayesinde main
        // fonksiyonunun goroutine'yi beklemesi saÄŸlanabilir.
        
        // Daha Ã§ok gÃ¼venliÄŸi saÄŸlamak iÃ§in kullanÄ±lan unidirectional kanallar
        // oluÅŸturulabilir. Kanal yine Ã§ift yÃ¶nlÃ¼ olarak oluÅŸturulur. Ancak bir fonksiyona
        // tek yÃ¶nlÃ¼ kanal gÃ¶nderilmesi iÃ§in parametre tek yÃ¶nlÃ¼ olarak tanÄ±mlanÄ±r.
        // Ya da return deÄŸeri tek yÃ¶nlÃ¼ olarak yazÄ±lÄ±r. BÃ¶ylece fonksiyondan dÃ¶nen
        // kanalÄ±n kÃ¶tÃ¼ye kullanÄ±mÄ±nÄ±n Ã¶nÃ¼ne geÃ§ilmiÅŸ olur.
        func sendData(sendch chan<- int) {  
            sendch <- 10
        }
        
        func main() {  
            chnl := make(chan int)
            go sendData(chnl)
            fmt.Println(<-chnl)
        }
        
        func F() <-chan int {
            // Create a regular, two-way channel.
            c := make(chan int)
        
            go func() {
                defer close(c)
        
                // Do stuff
                c <- 123
            }()
        
            // Returning it, implicitely converts it to read-only,
            // as per the function return value.
            return c
        }
        
        // Bir kanal close() fonksiyonu sayesinde kapatÄ±labilir. ArtÄ±k kanal Ã¼zerinden veri
        // gÃ¶nderilip alÄ±namaz.
        // "v, ok:= <-chnl"
        // YukarÄ±daki gibi eÄŸer ok deÄŸiÅŸkeni false ise kanal kapalÄ±dÄ±r. AÃ§Ä±k ise veri
        // baÅŸarÄ±yla ulaÅŸmÄ±ÅŸtÄ±r. EÄŸer kanal akapalÄ± ise value, kanalÄ±n zero-value'si olur.
        func producer(chnl chan int) {
        	for i := 0; i < 10; i++ {
        		chnl <- i
        	}
        	close(chnl)
        }
        func main() {
        	ch := make(chan int)
        	go producer(ch)
        	for {
        		v, ok := <-ch
        		if !ok {
        			break
        		}
        		fmt.Println("Received ", v, ok)
        	}
        }
        
        // For-range yardÄ±mÄ±yla kanalÄ±n iÃ§indeki veriler Ã¼zerinde gezinilebilir.
        // ElemanÄ±n Ã¼zerinde gezinildiÄŸinde iÃ§indeki dedÄŸerin okunduÄŸu anlamÄ±na gelir.
        // Kanal kapandÄ±ÄŸÄ±nda ise dÃ¶ngÃ¼ biter.
        func producer(chnl chan int) {
        	for i := 0; i < 10; i++ {
        		chnl <- i
        	}
        	close(chnl)
        }
        func main() {
        	ch := make(chan int)
        	go producer(ch)
        	for v := range ch {
        		fmt.Println("Received ", v)
        	}
        } 
        
        // iÃ§ iÃ§e goroutine ve channel kullanÄ±mÄ±na gÃ¼zel bir Ã¶rnek
        func digits(number int, dchnl chan int) {  
            for number != 0 {
                digit := number % 10
                dchnl <- digit
                number /= 10
            }
            close(dchnl)
        }
        func calcSquares(number int, squareop chan int) {  
            sum := 0
            dch := make(chan int)
            go digits(number, dch)
            for digit := range dch {
                sum += digit * digit
            }
            squareop <- sum
        }
        
        func calcCubes(number int, cubeop chan int) {  
            sum := 0
            dch := make(chan int)
            go digits(number, dch)
            for digit := range dch {
                sum += digit * digit * digit
            }
            cubeop <- sum
        }
        
        func main() {  
            number := 589
            sqrch := make(chan int)
            cubech := make(chan int)
            go calcSquares(number, sqrch)
            go calcCubes(number, cubech)
            squares, cubes := <-sqrch, <-cubech
            fmt.Println("Final output", squares+cubes)
        }
        ```
        
    - Buffered Channel
        
        ```go
        /*
        	Bu zamana kadarki channeller unbuffered channel'lardÄ±. Bir kanala bir mesaj
        	gÃ¶nderildikten sonra o mesaj okunana kadar kod bloklanÄ±rdÄ±. Bir kanalda sadece
        	bir mesaj olabilirdi. Ã‡Ã¼nkÃ¼ iÅŸin iÃ§inde buffer yoktu.
        	Ancak ÅŸimdi buffer dahil olduÄŸu iÃ§in kuyrukta mesaj bekletebiliyoruz.
        	Kanal tamamen dolu ya da boÅŸ olmadÄ±ÄŸÄ± sÃ¼rece gÃ¶nderici/alÄ±cÄ± bloklanmaz.
        	Buffered channel, make() fonksiyonu ile yapÄ±lÄ±yor. Ä°kinci argÃ¼man, kanalÄ±n
        	yani buffer'in kapasitesi. Kanalda en fazla kaÃ§ mesaj bulunduÄŸunu belirtiyor.
        	Buffer, FIFO mantÄ±ÄŸÄ±na sahip.
        	Buffer'siz kanallar, goroutine'ler dÄ±ÅŸÄ±nda kullanÄ±lamÄ±yordu Ã§Ã¼nkÃ¼ gÃ¶nderilen
        	bir mesaj alÄ±nana kadar kod bloklanÄ±rdÄ±. Ama ÅŸimdi birden fazla mesaj
        	gÃ¶nderilebildiÄŸi iÃ§in kod bloklanmaz(channel boÅŸ/dolu olmazsa)
        	newChl := make(chan int, 2)
        */
        func main() {  
            ch := make(chan string, 2)
            ch <- "said"
            ch <- "taylan"
            fmt.Println(<- ch)
            fmt.Println(<- ch)
        }
        
        /*
        	Buffered channel evet FIFO ile hareket eder. Ama channel birden fazla kez
        	kullanÄ±ldÄ±ÄŸÄ±nda nasÄ±l gerÃ§ekleÅŸir. Let's see
        */
        func write(ch chan int) {
        	for i := 0; i < 5; i++ {
        		ch <- i
        		fmt.Println("successfully wrote", i, "to ch")
        	}
        	close(ch)
        }
        func main() {
        	ch := make(chan int, 2)
        	go write(ch)
        	time.Sleep(2 * time.Second)
        	for v := range ch {
        		fmt.Println("read value", v, "from ch")
        		time.Sleep(2 * time.Second)
        
        	}
        }
        
        /* Ã‡Ä±ktÄ±sÄ±:
        successfully wrote 0 to ch  
        successfully wrote 1 to ch  
        read value 0 from ch  
        successfully wrote 2 to ch  
        read value 1 from ch  
        successfully wrote 3 to ch  
        read value 2 from ch  
        successfully wrote 4 to ch  
        read value 3 from ch  
        read value 4 from ch
        */
        
        // close() ile kapanmÄ±i kanallardan da iÃ§indeki verileri okunabilir:
        func main() {  
            ch := make(chan int, 5)
            ch <- 5
            ch <- 6
            close(ch)
            for n := range ch {
                fmt.Println("Received:", n)
            }
        }
        
        // len(chnl), kuyruktaki mesajlarÄ±n sayÄ±sÄ±nÄ± verir.
        ```
        
    - Wait Group
        
        Threadâ€™lerdeki wait() ile benzer iÅŸi gÃ¶rÃ¼r. Ya da Javascriptâ€™tki Promise.All gibi dÃ¼ÅŸÃ¼nÃ¼lebilir. Goroutineâ€™lerin bitmesini bekler ve programa ondan sonra devam eder. 
        
        ```go
        import (  
            "fmt"
            "sync"
            "time"
        )
        
        func process(i int, wg *sync.WaitGroup) {  
            fmt.Println("started Goroutine ", i)
            time.Sleep(2 * time.Second)
            fmt.Printf("Goroutine %d ended\n", i)
            wg.Done()
        }
        
        func main() {  
            no := 3
            var wg sync.WaitGroup
            for i := 0; i < no; i++ {
                wg.Add(1)
                go process(i, &wg)
            }
            wg.Wait()
            fmt.Println("All go routines finished executing")
        }
        ```
        
    - Worker Pool
        
        ```go
        /*
        	Thread pool gibi dÃ¼ÅŸÃ¼nÃ¼lebilir. Az goroutine ile fazla iÅŸ yapmayÄ± hedefler.
        	Worker sayÄ±sÄ± for dÃ¶ngÃ¼sÃ¼nÃ¼n dÃ¶nÃ¼ÅŸ sayÄ±sÄ±nÄ± belirmektedir.
        	DÃ¶ngÃ¼de ise yapÄ±lmasÄ± istenen iÅŸin fonksiyonu goroutine ile Ã§alÄ±ÅŸtÄ±rÄ±lÄ±r.
        	Ana fonksiyon iÃ§inde Job ve Result kanallarÄ± oluÅŸturulur. Ä°ÅŸin fonksiyonu
        	iÃ§inde Jobs kanalÄ± Ã¼zerinde range ile dÃ¶nÃ¼lerek iÅŸler yapÄ±lÄ±r.
        	YapÄ±lan iÅŸler Result kanalÄ±na atÄ±lÄ±r. 
        	Job kanalÄ±na iÅŸler, bir for dÃ¶ngÃ¼sÃ¼ ile gidebilir.
        */ 
        func worker(id int, jobs <-chan int, results chan<- int) {
        	for j := range jobs {
        		fmt.Println("worker", id, "started  job", j)
        		// YapÄ±lacak iÅŸ vs...
        		time.Sleep(time.Second)
        		fmt.Println("worker", id, "finished job", j)
        		results <- j * 2
        	}
        }
        
        func main() {
        
        	// Ä°ÅŸÃ§ilere gÃ¶rev vermek ve sonuÃ§larÄ±nÄ± almak iÃ§in
        	// jobs ve results isimli iki kanal oluÅŸturuyoruz.
        	jobs := make(chan int, 100)
        	results := make(chan int, 100)
        
        	// Uygulamada 3 iÅŸÃ§i Ã§alÄ±ÅŸtÄ±rmaktayÄ±z. BaÅŸlangÄ±Ã§ta
        	// bu iÅŸÃ§iler bloklanmÄ±ÅŸ durumda Ã§Ã¼nkÃ¼ jobs kanalÄ±nda
        	// herhangi bir iÅŸ bulunmamaktadÄ±r.
        	for w := 1; w <= 3; w++ {
        		go worker(w, jobs, results)
        	}
        
        	// Burada jobs kanalÄ±na 5 gÃ¶rev gÃ¶nderiyor ve sonrasÄ±nda
        	// kanalÄ± kapatÄ±yoruz.
        	for j := 1; j <= 5; j++ {
        		jobs <- j
        	}
        	close(jobs)
        
        	// Son olarak sonuÃ§larÄ± yazdÄ±rÄ±yoruz.
        	for a := 1; a <= 5; a++ {
        		<-results
        	}
        	
        ```
        
    - Select-case
        
        ```go
        /*
        Case'lerde belirtilen expression'lardan Ã¶nce hangisi hazÄ±r olursa o case Ã§alÄ±ÅŸÄ±r
        EÄŸer hiÃ§biri Ã§alÄ±ÅŸmazsa default case Ã§alÄ±ÅŸÄ±r.
        */
        func process(ch chan string) {  
            time.Sleep(10500 * time.Millisecond)
            ch <- "process successful"
        }
        
        func main() {  
            ch := make(chan string)
            go process(ch)
            for {
                time.Sleep(1000 * time.Millisecond)
                select {
                case v := <-ch:
                    fmt.Println("received value: ", v)
                    return
                default:
                    fmt.Println("no value received")
                }
            }
        
        }
        ```
        
    - Mutex
        
        ```go
        /*
        	Race condition iÃ§in kullanÄ±lan bir kilit mekanizmasÄ±dÄ±r. Gayet basit Ã§alÄ±ÅŸÄ±r:
        	Ä°ÅŸi olan fonksiyon critical section'dan Ã¶nce Lock() atar ve iÅŸi bitince de
        	critical section'dan sonra Unlock() atar.
        */
        var x  = 0  
        func increment(wg *sync.WaitGroup, m *sync.Mutex) {  
            m.Lock()
            x = x + 1
            m.Unlock()
            wg.Done()   
        }
        func main() {  
            var w sync.WaitGroup
            var m sync.Mutex
            for i := 0; i < 1000; i++ {
                w.Add(1)        
                go increment(&w, &m)
            }
            w.Wait()
            fmt.Println("final value of x", x)
        }
        
        /* 
        	AslÄ±nda mutex'e bir diÄŸer alternatif channel'dir. Critical setion'dan hemen
        	Ã¶nce ve sonra 1 kapasiteli kanala okuma ve yazma yaparsak aradaki koda baÅŸka
        	kimse eriÅŸemez. Ã‡Ã¼nkÃ¼ channel'in boyutu zaten 1 ve iÃ§indeki veri okunamÄ±ÅŸ.
        	Ä°Ã§indeki veri okunmamÄ±ÅŸken kendisinden baÅŸka bir yazma iÅŸlemine izin
        	vermeyeceÄŸinden aradaki kod gÃ¼vende olur.
        */
        var x  = 0  
        func increment(wg *sync.WaitGroup, ch chan bool) {  
            ch <- true
            x = x + 1
            <- ch
            wg.Done()   
        }
        func main() {  
            var w sync.WaitGroup
            ch := make(chan bool, 1)
            for i := 0; i < 1000; i++ {
                w.Add(1)        
                go increment(&w, ch)
            }
            w.Wait()
            fmt.Println("final value of x", x)
        }
        ```
        
- Object Oriented and GO
    
    ```go
    /*
    	Go'da constructor metodu olmadÄ±ÄŸÄ±ndan bir New metodu
    	oluÅŸturulabilir. Obje ilk create edildiÄŸinde bu metot Ã§aÄŸrÄ±lÄ±rsa
    	constructor saÄŸlanmÄ±ÅŸ olur.
    */
    type employee struct {  
        firstName   string
        lastName    string
        totalLeaves int
        leavesTaken int
    }
    
    func New(firstName string,
    				lastName string,
    				totalLeave int,
    				leavesTaken int) employee {  
        e := employee {firstName, lastName, totalLeave, leavesTaken}
        return e
    }
    
    func (e employee) LeavesRemaining() {  
        fmt.Printf("%s %s has %d leaves remaining\n", e.firstName, e.lastName,
    								(e.totalLeaves - e.leavesTaken)
    							)
    }
    func main() {  
        e := employee.New("Sam", "Adolf", 30, 20)
    }
    
    /*
    	Go'da inheritance, nested struct'lar ile saÄŸlanabilir. DÄ±ÅŸ struct, iÃ§ine aldÄ±ÄŸÄ±
    	struct'Ä±n alanlarÄ±nÄ±, sanki kendi alanÄ±ymÄ±ÅŸ gibi kullanabilir.
    */
    type author struct {  
        firstName string
        lastName  string
        bio       string
    }
    
    func (a author) fullName() string {  
        return fmt.Sprintf("%s %s", a.firstName, a.lastName)
    }
    
    type blogPost struct {  
        title   string
        content string
        author
    }
    
    func (b blogPost) details() {  
        fmt.Println("Title: ", b.title)
        fmt.Println("Content: ", b.content)
        fmt.Println("Author: ", b.fullName())
        fmt.Println("Bio: ", b.bio)
    }
    
    func main() {  
        author1 := author{
            "Naveen",
            "Ramanathan",
            "Golang Enthusiast",
        }
        blogPost1 := blogPost{
            "Inheritance in Go",
            "Go supports composition instead of inheritance",
            author1,
        }
        blogPost1.details()
    }
    
    /*
    	Slice'lar struct'lara anonymous olarak eklenemez. Ä°smi de belirtilmelidir.
    */
    type author struct {  
        firstName string
        lastName  string
        bio       string
    }
    
    func (a author) fullName() string {  
        return fmt.Sprintf("%s %s", a.firstName, a.lastName)
    }
    
    type blogPost struct {  
        title   string
        content string
        author
    }
    
    func (p blogPost) details() {  
        fmt.Println("Title: ", p.title)
        fmt.Println("Content: ", p.content)
        fmt.Println("Author: ", p.fullName())
        fmt.Println("Bio: ", p.bio)
    }
    
    type website struct {  
        blogPosts []blogPost
    }
    
    func (w website) contents() {  
        fmt.Println("Contents of Website\n")
        for _, v := range w.blogPosts {
            v.details()
            fmt.Println()
        }
    }
    
    func main() {  
        author1 := author{
            "Naveen",
            "Ramanathan",
            "Golang Enthusiast",
        }
        blogPost1 := blogPost{
            "Inheritance in Go",
            "Go supports composition instead of inheritance",
            author1,
        }
        blogPost2 := blogPost{
            "Struct instead of Classes in Go",
            "Go does not support classes but methods can be added to structs",
            author1,
        }
        blogPost3 := blogPost{
            "Concurrency",
            "Go is a concurrent language and not a parallel one",
            author1,
        }
        w := website{
            blogPosts: []blogPost{blogPost1, blogPost2, blogPost3},
        }
        w.contents()
    }
    
    /*
    	GO'da polymorphism Interface'ler ile saÄŸlanabilir. Interface, kullanÄ±lacak
    	metotllarÄ± belirtir ve her tip bunu kendisine gÃ¶re yorumlar.
    */
    ```
    
- Defer
    
    ```go
    /*
    	Fonksiyon tamamlanmadan hemen Ã¶nce bir fonksiyon/metot Ã§alÄ±ÅŸtÄ±rÄ±r.
    */
    type person struct {  
    firstName string
    lastName string
    }
    
    func (p person) fullName() {  
        fmt.Printf("%s %s",p.firstName,p.lastName)
    }
    
    func main() {  
        p := person {
            firstName: "John",
            lastName: "Smith",
        }
        defer p.fullName()
        fmt.Printf("Welcome ")  
    }
    
    /*
    	Ã‡aÄŸrÄ±lan fonksiyon/metotta herhangi bir argÃ¼man varsa, 
    	bu argÃ¼man defer'den Ã¶nce belirtilmelidir.
    */
    func printA(a int) {  
        fmt.Println("value of a in deferred function", a)
    }
    func main() {  
        a := 5
        defer printA(a)
        a = 10
        fmt.Println("value of a before deferred function call", a)
    
    }
    /* result: 
    	value of a before deferred function call 10  
    	value of a in deferred function 5
    */
    
    /*
    	Bir fonksiyonda birden Ã§ok defer kullanÄ±labilir.
    	Defer'ler LIFO mantÄ±ÄŸÄ±na gÃ¶re stack'lanÄ±r.
    */
    func main() {  
        name := "Naveen"
        fmt.Printf("Original String: %s\n", string(name))
        fmt.Printf("Reversed String: ")
        for _, v := range []rune(name) {
            defer fmt.Printf("%c", v)
        }
    }
    /* result:
    	Original String: Naveen  
    	Reversed String: neevaN
    */
    
    /* 
    	Defer'in pratik kullanÄ±mlarÄ±ndan birisi; WaitGroup kullanÄ±yorsak
    	ve return edilmesi gereken if bloklarÄ± varsa her blokta wg.Done()
    	yapmaktansa fonksiyonun baÅŸÄ±nda defer wg.Done() yapmak yeterlidir
    */
    ```
    
- Panic and Recover
    
    ```go
    /* 
    	BazÄ± normal olmayan durumlarda program Ã§alÄ±ÅŸmaya devam edemez.
    	Bu durumda, 'panic' Ã§alÄ±ÅŸmayÄ± durdurur. Program Ã§alÅŸmayÄ± sonlandÄ±rmadan
    	Ã¶nce defer statement'leri Ã§alÄ±ÅŸÄ±r. 
    */
    func fullName(firstName *string, lastName *string) {  
        if firstName == nil {
            panic("runtime error: first name cannot be nil")
        }
        if lastName == nil {
            panic("runtime error: last name cannot be nil")
        }
        fmt.Printf("%s %s\n", *firstName, *lastName)
        fmt.Println("returned normally from fullName")
    }
    
    func main() {  
        firstName := "Elon"
        fullName(&firstName, nil)
        fmt.Println("returned normally from main")
    }
    
    /*
    	OluÅŸan panic'i kurtarmak ve programÄ±n Ã§Ã¶kmesini Ã¶nlemek iÃ§in
    	recover() vardÄ±r. Return deÄŸeri olarka panic sebebini dÃ¶ner.
    	KurtarÄ±ldÄ±ktan sonra fonksiyondan Ã§Ä±kÄ±p fonksiyonun
    	Ã§aÄŸrÄ±ldÄ±ÄŸÄ± satÄ±rdan bir sonraki satÄ±rdan kod devam eder.
    */
    func recoverFullName() {  
        if r := recover(); r!= nil {
            fmt.Println("recovered from ", r)
        }
    }
    
    func fullName(firstName *string, lastName *string) {  
        defer recoverFullName()
        if firstName == nil {
            panic("runtime error: first name cannot be nil")
        }
        if lastName == nil {
            panic("runtime error: last name cannot be nil")
        }
        fmt.Printf("%s %s\n", *firstName, *lastName)
        fmt.Println("returned normally from fullName")
    }
    
    func main() {  
        defer fmt.Println("deferred call in main")
        firstName := "Elon"
        fullName(&firstName, nil)
        fmt.Println("returned normally from main")
    }
    /* result:
    	recovered from  runtime error: last name cannot be nil
    	returned normally from main
    	deferred call in main
    */
    
    /*
    	Recover() edildikten sonra panic'in stack trace'si kaybolur
    	yani nerelerden nerelere sÄ±Ã§rayarak bu hataya ulaÅŸtÄ±k.
    	Bunu gÃ¶rmek iÃ§in debug paketini import ediyoruz.
    */
    import (  
        "fmt"
        "runtime/debug"
    )
    
    func recoverFullName() {  
        if r := recover(); r != nil {
            fmt.Println("recovered from ", r)
            debug.PrintStack()
        }
    }
    
    func fullName(firstName *string, lastName *string) {  
        defer recoverFullName()
        if firstName == nil {
            panic("runtime error: first name cannot be nil")
        }
        if lastName == nil {
            panic("runtime error: last name cannot be nil")
        }
        fmt.Printf("%s %s\n", *firstName, *lastName)
        fmt.Println("returned normally from fullName")
    }
    
    func main() {  
        defer fmt.Println("deferred call in main")
        firstName := "Elon"
        fullName(&firstName, nil)
        fmt.Println("returned normally from main")
    }
    /*  result:
    	recovered from  runtime error: last name cannot be nil  
    	goroutine 1 [running]:  
    	runtime/debug.Stack(0x37, 0x0, 0x0)  
        /usr/local/go-faketime/src/runtime/debug/stack.go:24 +0x9d
    	runtime/debug.PrintStack()  
        /usr/local/go-faketime/src/runtime/debug/stack.go:16 +0x22
    	main.recoverFullName()  
        /tmp/sandbox771195810/prog.go:11 +0xb4
    	panic(0x4a1b60, 0x4dc300)  
        /usr/local/go-faketime/src/runtime/panic.go:969 +0x166
    	main.fullName(0xc0000a2f28, 0x0)  
        /tmp/sandbox771195810/prog.go:21 +0x1cb
    	main.main()  
        /tmp/sandbox771195810/prog.go:30 +0xc6
    	returned normally from main  
    	deferred call in main  
    */
    
    /*
    	BaÅŸka bir goroutine'deki panic'i rercover() etmek mÃ¼mkÃ¼n deÄŸildir.
    */
    func recovery() {  
        if r := recover(); r != nil {
            fmt.Println("recovered:", r)
        }
    }
    
    func sum(a int, b int) {  
        defer recovery()
        fmt.Printf("%d + %d = %d\n", a, b, a+b)
        done := make(chan bool)
        go divide(a, b, done)
        <-done
    }
    
    func divide(a int, b int, done chan bool) {  
        fmt.Printf("%d / %d = %d", a, b, a/b)
        done <- true
    
    }
    
    func main() {  
        sum(5, 0)
        fmt.Println("normally returned from main")
    }
    ```
    
    - First Class Function
        
        Anonymous functions olarak da dÃ¼ÅŸÃ¼nÃ¼lebilir. Bir isimsiz fonksiyonun bir deÄŸiÅŸkene atanmasÄ±, bir fonksiyona parametre olarak geÃ§mesi ve bir fonksiyonun return edilmesi 
        
        ```go
        // Anonymous functions
        func main() {  
            a := func() {
                fmt.Println("hello world first class function")
            }
            a()
            fmt.Printf("%T", a)
        }
        
        // TanÄ±mlanan bir anonymous function deÄŸiÅŸkene atanmadan hemen Ã§alÄ±ÅŸtÄ±rÄ±labilir
        func main() {  
            func() {
                fmt.Println("hello world first class function")
            }()
        }
        
        // Ã‡aÄŸrÄ±lan fonksiyona parametre de verilebilir.
        func main() {  
            func(n string) {
                fmt.Println("Welcome", n)
            }("Gophers")
        }
        
        /*	
        	Tip tanÄ±mlar gibi fonksiyon imzasÄ± ile tip tanÄ±mlanÄ±p bu tipte
        	oluÅŸturulan bir deÄŸÅŸÅŸkeneanonymous function atanabilir.
        */
        type add func(a int, b int) int
        
        func main() {  
            var a add = func(a int, b int) int {
                return a + b
            }
            s := a(5, 6)
            fmt.Println("Sum", s)
        }
        
        /* 
        	High Order Functions: Bir fonksiyona argÃ¼man olarak bir fonksiyon verilmesi
        	ya da bir fonksiyonun return olarak bir fonksiyon dÃ¶nmesi
        */
        func simple(a func(a, b int) int) {  
            fmt.Println(a(60, 7))
        }
        
        func main() {  
            f := func(a, b int) int {
                return a + b
            }
            simple(f)
        }
        
        /*
        	Closure Functions: Bir fonksiyonun, kendisini kapsayan
        	fonksiyon/fonksiyonlarÄ±n deÄŸiÅŸkenlerine eriÅŸmesi.
        	KullanÄ±mÄ±nda, iÃ§teki fonksiyon anladÄ±ÄŸÄ±m kadarÄ±yla return edilmek zorunda
        	ama eÄŸer return edilmezse Ã§aÄŸrÄ±lmak zorunda. EÄŸer return edilirse dÃ¶ndÃ¼ÄŸÃ¼
        	yerde parantezler ile iÃ§teki fonksiyon Ã§aÄŸrÄ±labiliyor.
        */
        func appendStr() func(string) string {  
            t := "Hello"
            c := func(b string) string {
                t = t + " " + b
                return t
            }
            return c
        }
        
        func main() {  
            a := appendStr()
            b := appendStr()
            fmt.Println(a("World"))
            fmt.Println(b("Everyone"))
        
            fmt.Println(a("Gopher"))
            fmt.Println(b("!"))
        }
        ```
        
    - Reflect
        
        ```go
        /* 
        	Tipi interface olan bir deÄŸiÅŸkenin run-time'da Tipini, tÃ¼rÃ¼nÃ¼, deÄŸerini
        	tespit etmeyi saÄŸlar. Ancak kod okunurluÄŸunu azalttÄ±ÄŸÄ± ve bakÄ±m maliyetini
        	artÄ±rdÄ±ÄŸÄ± iÃ§in mÃ¼mkÃ¼n olduÄŸuna kaÃ§Ä±nÄ±lmalÄ±dÄ±r.
        */
        
        // reflect.TypeOf(q) ve reflect.ValueOf(q) sÄ±rasÄ±yla tip ve deÄŸerini verir.
        import (  
            "fmt"
            "reflect"
        )
        
        type order struct {  
            ordId      int
            customerId int
        }
        
        func createQuery(q interface{}) {  
            t := reflect.TypeOf(q)
            v := reflect.ValueOf(q)
            fmt.Println("Type ", t)
            fmt.Println("Value ", v)
        
        }
        func main() {  
            o := order{
                ordId:      456,
                customerId: 56,
            }
            createQuery(o)
        
        }
        /* result:
        	Type  main.order  
        	Value  {456 56}
        */
        
        /*
        	reflect.Kind() bir tipin(type) tÃ¼rÃ¼nÃ¼ sÃ¶yler. Ã–rneÄŸin Order tipinin underlying
        	tipi struct'tÄ±r.
        */
        type order struct {  
            ordId      int
            customerId int
        }
        
        func createQuery(q interface{}) {  
            t := reflect.TypeOf(q)
            k := t.Kind()
            fmt.Println("Type ", t)
            fmt.Println("Kind ", k)
        
        }
        func main() {  
            o := order{
                ordId:      456,
                customerId: 56,
            }
            createQuery(o)
        
        }
        /* result:
        	Type  main.order  
        	Kind  struct
        */
        
        /*
        	v.NumField() ve v.Field(i) sÄ±rasÄ±yla deÄŸeri v olan struct'Ä±n
        	field'larÄ±nÄ±n sayÄ±sÄ±nÄ± ve struct iÃ§indeki field'larÄ±n sayÄ±sal sÄ±rasÄ±na gÃ¶re 
        	o field'in deÄŸerini verir.
        */
        type order struct {  
            ordId      int
            customerId int
        }
        
        func createQuery(q interface{}) {  
            if reflect.ValueOf(q).Kind() == reflect.Struct {
                v := reflect.ValueOf(q)
                fmt.Println("Number of fields", v.NumField())
                for i := 0; i < v.NumField(); i++ {
                    fmt.Printf("Field:%d type:%T value:%v\n", i, v.Field(i), v.Field(i))
                }
            }
        
        }
        func main() {  
            o := order{
                ordId:      456,
                customerId: 56,
            }
            createQuery(o)
        }
        /* result:
        	Number of fields 2  
        	Field:0 type:reflect.Value value:456  
        	Field:1 type:reflect.Value value:56
        */
        
        // Tam bir Ã¶rnek
        import (  
            "fmt"
            "reflect"
        )
        
        type order struct {  
            ordId      int
            customerId int
        }
        
        type employee struct {  
            name    string
            id      int
            address string
            salary  int
            country string
        }
        
        func createQuery(q interface{}) {  
            if reflect.ValueOf(q).Kind() == reflect.Struct {
                t := reflect.TypeOf(q).Name()
                query := fmt.Sprintf("insert into %s values(", t)
                v := reflect.ValueOf(q)
                for i := 0; i < v.NumField(); i++ {
                    switch v.Field(i).Kind() {
                    case reflect.Int:
                        if i == 0 {
                            query = fmt.Sprintf("%s%d", query, v.Field(i).Int())
                        } else {
                            query = fmt.Sprintf("%s, %d", query, v.Field(i).Int())
                        }
                    case reflect.String:
                        if i == 0 {
                            query = fmt.Sprintf("%s\"%s\"", query, v.Field(i).String())
                        } else {
                            query = fmt.Sprintf("%s, \"%s\"", query, v.Field(i).String())
                        }
                    default:
                        fmt.Println("Unsupported type")
                        return
                    }
                }
                query = fmt.Sprintf("%s)", query)
                fmt.Println(query)
                return
        
            }
            fmt.Println("unsupported type")
        }
        
        func main() {  
            o := order{
                ordId:      456,
                customerId: 56,
            }
            createQuery(o)
        
            e := employee{
                name:    "Naveen",
                id:      565,
                address: "Coimbatore",
                salary:  90000,
                country: "India",
            }
            createQuery(e)
            i := 90
            createQuery(i)
        
        }
        ```
        
    - Flags
- Flags
    
    ```go
    /*
        Programa flag geÃ§irmeyi saÄŸlar. GerÃ§i
        environment variable ile flag aynÄ± ÅŸey deÄŸil ama olsun.
    */
    func main() {
    
        wordPtr := flag.String("selam", "foo", "a string")
    
        numbPtr := flag.Int("numb", 42, "an int")
        forkPtr := flag.Bool("fork", false, "a bool")
    
        // Flag'Ä±n bir deÄŸiÅŸkene atanmasÄ±nÄ± saÄŸlar.
        // DiÄŸer flag'lar gibi dereferance yapÄ±lmasÄ±na gerek yok.
        var svar string
        flag.StringVar(&svar, "svar", "bar", "a string var")
    
        flag.Parse()
    
        fmt.Println("selam:", *wordPtr)
        fmt.Println("numb:", *numbPtr)
        fmt.Println("fork:", *forkPtr)
        fmt.Println("svar:", svar)
        fmt.Println("tail:", flag.Args())
    }
    
    /* result:
        go run main.go -word=opt -numb=7 -fork -svar=flag
    
            word: opt
            numb: 7
            fork: true
            svar: flag
            tail: []
    */
    ```
    
- Read Files
    
    ```go
    /* 
      ioutil kÃ¼tÃ¼phanesindeki ReadFile metodu ile bir anda
      bÃ¼tÃ¼n iÃ§erik bir anda okunabilir. Ancak okunan karakterler
      byte ÅŸeklindedir. BunlarÄ±n stringify edilmesi gerekir.
    */
    import (  
        "fmt"
        "io/ioutil"
    )
    
    func main() {  
        data, err := ioutil.ReadFile("test.txt")
        if err != nil {
            fmt.Println("File reading error", err)
            return
        }
        fmt.Println("Contents of file:", string(data))
    }
    
    // Flag'ler ile dosya yolu belirtilebilir.
    func main() {  
        fptr := flag.String("fpath", "test.txt", "file path to read from")
        flag.Parse()
        data, err := ioutil.ReadFile(*fptr)
        if err != nil {
            fmt.Println("File reading error", err)
            return
        }
        fmt.Println("Contents of file:", string(data))
    }
    
    /*
    	Ä°Ã§eriÄŸi direkt RAM'e yÃ¼kleyip okumak yerine chunk chunk okunabilir.
    */
    func main() {  
        fptr := flag.String("fpath", "test.txt", "file path to read from")
        flag.Parse()
    
        f, err := os.Open(*fptr)
        if err != nil {
            log.Fatal(err)
        }
        defer func() {
            if err = f.Close(); err != nil {
                log.Fatal(err)
            }
        }()
        r := bufio.NewReader(f)
        b := make([]byte, 3)
        for {
            n, err := r.Read(b)
            if err != nil {
                fmt.Println("Error reading file:", err)
                break
            }
            fmt.Println(string(b[0:n]))
        }
    }
    ```
    
- Write Files
    
    ```go
    func main() {  
        f, err := os.Create("test.txt")
        if err != nil {
            fmt.Println(err)
            return
        }
        l, err := f.WriteString("Hello World")
        if err != nil {
            fmt.Println(err)
            f.Close()
            return
        }
        fmt.Println(l, "bytes written successfully")
        err = f.Close()
        if err != nil {
            fmt.Println(err)
            return
        }
    }
    
    // Concurrent file writing
    func produce(data chan int, wg *sync.WaitGroup) {  
        n := rand.Intn(999)
        data <- n
        wg.Done()
    }
    
    func consume(data chan int, done chan bool) {  
        f, err := os.Create("concurrent")
        if err != nil {
            fmt.Println(err)
            return
        }
        for d := range data {
            _, err = fmt.Fprintln(f, d)
            if err != nil {
                fmt.Println(err)
                f.Close()
                done <- false
                return
            }
        }
        err = f.Close()
        if err != nil {
            fmt.Println(err)
            done <- false
            return
        }
        done <- true
    }
    
    func main() {  
        data := make(chan int)
        done := make(chan bool)
        wg := sync.WaitGroup{}
        for i := 0; i < 100; i++ {
            wg.Add(1)
            go produce(data, &wg)
        }
        go consume(data, done)
        go func() {
            wg.Wait()
            close(data)
        }()
        d := <-done
        if d == true {
            fmt.Println("File written successfully")
        } else {
            fmt.Println("File writing failed")
        }
    }
    ```
    
- JSON
    
    ```go
    /*
    	[]byte, err := json.Marshal(structVar) : Bir struct deÄŸiÅŸkenini json'a
    																					 parse eder, Ã§evirir. Geriye bir byte
    																					 dizisi dÃ¶ner.
    	json.Unmarshal(jsonBytes, &targetStruct): Bir json'Ä± struct'a parse eder. Geriye
    																						sadece bir hata dÃ¶ner.  
    */
    goldZone:=Game{
      5555,
      "Mohani Gezegeni GÃ¶revi",
      []Player{
          Player{100,"deli","cevat",10.90},
          Player{102,"nadya","komenaÃ§Ã§i",12.45},
          Player{103,"biricit","bardot",900.45},
      },
    }   
    
    jsonOutput,_:=json.Marshal(goldZone)
    fmt.Println(string(jsonOutput))
    
    var game Game   
    if err := json.Unmarshal(jsonOutput,&game); err != nil {
          panic(err)
      }
    
    fmt.Printf("Game : %s\n",game.Name)
    
    /*
    	Struct'taki JSON alanlarÄ±na 'json tag' denir.
    	EÄŸer bir json tag'da "-" iÅŸareti varsa bu iÅŸaret atÄ±lÄ±r, yok sayÄ±lÄ±r.
    	"omitempty" ifadesi, yazÄ±lan json tag'Ä±nÄ±n parse edilecek olan json'a Ã§Ä±ktÄ±
    	vermemesini saÄŸlar
    
    type Server struct {
        ServerName string `json:"serverName"`
        ServerIP   string `json:"serverIP"`
    }
    
    type Serverslice struct {
        Servers []Server `json:"servers"`
    }
    ```
    
- Time
    
    ```go
    func main() {
        p := fmt.Println
    
        now := time.Now()
        p(now)
    
        then := time.Date(
            2009, 11, 17, 20, 34, 58, 651387237, time.UTC)
        p(then)
    
        p(then.Year())
        p(then.Month())
        p(then.Day())
        p(then.Hour())
        p(then.Minute())
        p(then.Second())
        p(then.Nanosecond())
        p(then.Location())
    
        p(then.Weekday())
    
        p(then.Before(now))
        p(then.After(now))
        p(then.Equal(now))
    
        diff := now.Sub(then)
        p(diff)
    
        p(diff.Hours())
        p(diff.Minutes())
        p(diff.Seconds())
        p(diff.Nanoseconds())
    
        p(then.Add(diff))
        p(then.Add(-diff))
    }
    /* result:
    	2012-10-31 15:50:13.793654 +0000 UTC
    	2009-11-17 20:34:58.651387237 +0000 UTC
    	2009
    	November
    	17
    	20
    	34
    	58
    	651387237
    	UTC
    	Tuesday
    	true
    	false
    	false
    	25891h15m15.142266763s
    	25891.25420618521
    	1.5534752523711128e+06
    	9.320851514226677e+07
    	93208515142266763
    	2012-10-31 15:50:13.793654 +0000 UTC
    	2006-12-05 01:19:43.509120474 +0000 UTC
    */
    ```
    
- URL Parsing
    
    ```go
    func main() {
    
        s := "postgres://user:pass@host.com:5432/path?k=v#f"
    
        u, err := url.Parse(s)
        if err != nil {
            panic(err)
        }
    
        fmt.Println(u.Scheme)
    
        fmt.Println(u.User)
        fmt.Println(u.User.Username())
        p, _ := u.User.Password()
        fmt.Println(p)
    
        fmt.Println(u.Host)
        host, port, _ := net.SplitHostPort(u.Host)
        fmt.Println(host)
        fmt.Println(port)
    
        fmt.Println(u.Path)
        fmt.Println(u.Fragment)
    
        fmt.Println(u.RawQuery)
        m, _ := url.ParseQuery(u.RawQuery)
        fmt.Println(m)
        fmt.Println(m["k"][0])
    }
    
    /* result:
    	postgres
    	user:pass
    	user
    	pass
    	host.com:5432
    	host.com
    	5432
    	/path
    	f
    	k=v
    	map[k:[v]]
    	vpostgres
    	user:pass
    	user
    	pass
    	host.com:5432
    	host.com
    	5432
    	/path
    	f
    	k=v
    	map[k:[v]]
    	v
    */
    ```
    
- Command Line Arguments
    
    ```go
    func main() {
    
        argsWithProg := os.Args
        argsWithoutProg := os.Args[1:]
    
        arg := os.Args[3]
    
        fmt.Println(argsWithProg)
        fmt.Println(argsWithoutProg)
        fmt.Println(arg)
    }
    /* result:
    	go build main.go
    		./command-line-arguments a b c d
    			[./command-line-arguments a b c d]       
    			[a b c d]
    			c
    */
    ```
    
- Environment Variable
    
    ```go
    func main() {
    
        os.Setenv("FOO", "1")
        fmt.Println("FOO:", os.Getenv("FOO"))
        fmt.Println("BAR:", os.Getenv("BAR"))
    
        fmt.Println()
        for _, e := range os.Environ() {
            pair := strings.SplitN(e, "=", 2)
            fmt.Println(pair[0])
        }
    }
    /*
    $ go run environment-variables.go
    	FOO: 1
    	BAR: 
    	..
    	TERM_PROGRAM
    	PATH
    	SHELL
    
    $ BAR=2 go run environment-variables.go
    	FOO: 1
    	BAR: 2
    */
    ```
    
- Context
    
    ```go
    /*
    	Ä°ptal sinyallerini taÅŸÄ±yan ve iÃ§erisine veri gÃ¶mÃ¼lebilen bir veri tipidir.
    	Ã–rneÄŸin bir veritabanÄ±na bir istek atÄ±yoruz. Bu istek eÄŸer 3 saniyeyi aÅŸarsa
    	isteÄŸin iptal edilmesini saÄŸlayabiliyoruz.
    */
    
    /* Context yapÄ±sÄ±:
    	type Context interface {
    		// Done metodu, context tamamlandÄ±ÄŸÄ±nda veya zaman aÅŸÄ±mÄ±na uÄŸradÄ±ÄŸÄ±nda
      	// kapanan bir channel dÃ¶ndÃ¼rÃ¼r.
        Done() <-chan struct{}
    
      	// Err metodu, context'in neden kapandÄ±ÄŸÄ±nÄ± anlatan bir error dÃ¶ndÃ¼rÃ¼r.
        // Genellikle Done kanalÄ± kapandÄ±ktan sonra bunu kullanÄ±rÄ±z.
        Err() error
    
        // Deadline metodu, eÄŸer context herhangi bir deadline'a sahipse deadline
    		zamanÄ±nÄ± dÃ¶ndÃ¼rÃ¼r.
        // `ok` deÄŸeri context bir deadline'a sahipse true, deÄŸilse false olur.
        Deadline() (deadline time.Time, ok bool)
    
        // Value metodu, context'in iÃ§erisinde saklanan bilgilere ulaÅŸmak iÃ§in
    		kullanÄ±lÄ±r
        Value(key interface{}) interface{}
    }
    */
    
    /*
    	ctx, cancel := context.Background() boÅŸ bir context oluÅŸturur. DiÄŸer context'ler
    	iÃ§in temel bir context'tir.
    
    	ctx, cancel := context.TODO() boÅŸ bir context oluÅŸturur. Ancak ileride bu
    	context'in kullanÄ±lacaÄŸÄ±ndan emin deÄŸilsek kullanÄ±lÄ±r.
    
    	cancel := Context.WithCancel(context.Background()) geriye bir cancel metodu dÃ¶ner
    	ve Ã§aÄŸrÄ±ldÄ±ÄŸÄ± anda context iptal olur.
    	ctx, cancel :=:context.WithDeadline(context.Background(),
    																			time.Now().Add(2 * time.Second))
    	bitiÅŸ zamanÄ± verldiÄŸinde context'i bu zamanda iptal eder. Mnual olarak da iptal
    	edilebilir.
    	ctx, cancel :=:context.WithTimeout(context.Background(),
    																			time.Millisecond*time.Duration(150)), verilen
    	sÃ¼re dolduÄŸunda context'i iptal eder. Manual olarak da iptal edilebilir.
    
    	Genellikle case-select yapÄ±sÄ± ile kullanÄ±lÄ±r. Case'lerden biri ctx.Done()'dÄ±r.
    	EÄŸer ctx.Done() diÄŸer case'lerden Ã¶nce bir deÄŸer dÃ¶nerse yani context
    	elle cancel() edilirse ya da zamanÄ± dolduÄŸu iÃ§in biterse bu case Ã§alÄ±ÅŸÄ±r.
    	BÃ¶ylece diÄŸer case'ler iptal olmuÅŸ olur.
    	
    */
    
    ```
    
- Web
    - Form Fields
        
        ```html
        <html>
            <head>
            <title></title>
            </head>
            <body>
                <form action="/login" method="post">
                    Username:<input type="text" name="username">
                    Password:<input type="password" name="password">
                    <input type="submit" value="Login">
                </form>
            </body>
        </html>
        ```
        
        ```go
        import (
            "fmt"
            "html/template"
            "log"
            "net/http"
            "strings"
        )
        
        func sayhelloName(w http.ResponseWriter, r *http.Request) {
            r.ParseForm() //Parse url parameters passed, then parse the response packet for the POST body (request body)
            // attention: If you do not call ParseForm method, the following data can not be obtained form
            fmt.Println(r.Form) // print information on server side.
            fmt.Println("path", r.URL.Path)
            fmt.Println("scheme", r.URL.Scheme)
            fmt.Println(r.Form["url_long"])
            for k, v := range r.Form {
                fmt.Println("key:", k)
                fmt.Println("val:", strings.Join(v, ""))
            }
            fmt.Fprintf(w, "Hello astaxie!") // write data to response
        }
        
        func login(w http.ResponseWriter, r *http.Request) {
            fmt.Println("method:", r.Method) //get request method
            if r.Method == "GET" {
                t, _ := template.ParseFiles("login.gtpl")
                t.Execute(w, nil)
            } else {
                r.ParseForm()
                // logic part of log in
                fmt.Println("username:", r.Form["username"])
                fmt.Println("password:", r.Form["password"])
            }
        }
        
        func main() {
            http.HandleFunc("/", sayhelloName) // setting router rule
            http.HandleFunc("/login", login)
            err := http.ListenAndServe(":9090", nil) // setting listening port
            if err != nil {
                log.Fatal("ListenAndServe: ", err)
            }
        }
        ```
        
        ```go
        		v := url.Values{}
            v.Set("name", "Ava")
            v.Add("friend", "Jess")
            v.Add("friend", "Sarah")
            v.Add("friend", "Zoe")
            // v.Encode() == "name=Ava&friend=Jess&friend=Sarah&friend=Zoe"
            fmt.Println(v.Get("name"))
            fmt.Println(v.Get("friend"))
            fmt.Println(v["friend"])
        ```
        
        <aside>
        ğŸ’¡ r.ParseForm() yerine r.FormValue(â€nameâ€) ile de parse edilmeden deÄŸer alÄ±nabilir.
        
        </aside>
        
        <aside>
        ğŸ’¡ EÄŸer aynÄ± isme sahip birden fazla deÄŸer varsa bunlar slice ÅŸeklinde geÃ§er.
        
        </aside>
        
    - XSS (Cross Site Scripting)
        
        ```go
        /*
        	Ã–rneÄŸin input alanlarÄ±na js komutlarÄ± yazÄ±lmasÄ± gibi kÃ¶tÃ¼ niyetli iÅŸlemlerin
        	yapÄ±lmasÄ±nÄ± engelleyebiliriz. Bunun iÃ§in server'a gelen HTML kodlarÄ± herhangi
        	bir html tag'Ä± ya da js komutu iÃ§eriyorsa engellenir. Bunun iÃ§in Escape fonk-
        	siyonlarÄ± vardÄ±r.
        */
        
        // Client tarafÄ±ndan gelen veri string'e Ã§evilirip Ã¶zel karakterlerden kaÃ§Ä±lÄ±r.
        func HTMLEscapeString(s string) string
        
        // Client'a gidecek olan byte'lardaki Ã¶zel karakterlerden kaÃ§Ä±p Ã¶yle client'a
        // gelir.
        func HTMLEscape(w io.Writer, b []byte)
        
        // ExecuteTemplate ile client'a script Ã§alÄ±ÅŸtÄ±rÄ±labilir:
        err = t.ExecuteTemplate(out, "T", "<script>alert('you have ever...?')</script>")
        ```
        
    - File Uploading
        
        ```html
        <html>
        <head>
               <title>Upload file</title>
        </head>
        <body>
        <form enctype="multipart/form-data" action="http://127.0.0.1:9090/upload" method="post">
            <input type="file" name="uploadfile" />
            <input type="hidden" name="token" value="{{.}}"/>
            <input type="submit" value="upload" />
        </form>
        </body>
        </html>
        ```
        
        ```go
        type FileHeader struct {
               Filename string
               Header   textproto.MIMEHeader
               // contains filtered or unexported fields
        }
        
        import (
            "bytes"
            "fmt"
            "io"
            "io/ioutil"
            "mime/multipart"
            "net/http"
            "os"
        )
        
        http.HandleFunc("/upload", upload)
        
        // upload logic
        func upload(w http.ResponseWriter, r *http.Request) {
               fmt.Println("method:", r.Method)
               if r.Method == "GET" {
                   crutime := time.Now().Unix()
                   h := md5.New()
                   io.WriteString(h, strconv.FormatInt(crutime, 10))
                   token := fmt.Sprintf("%x", h.Sum(nil))
        
                   t, _ := template.ParseFiles("upload.gtpl")
                   t.Execute(w, token)
               } else {
                   r.ParseMultipartForm(32 << 20)
                   file, handler, err := r.FormFile("uploadfile")
                   if err != nil {
                       fmt.Println(err)
                       return
                   }
                   defer file.Close()
                   fmt.Fprintf(w, "%v", handler.Header)
                   f, err := os.OpenFile("./test/"+handler.Filename, os.O_WRONLY|os.O_CREATE, 0666)
                   if err != nil {
                       fmt.Println(err)
                       return
                   }
                   defer f.Close()
                   io.Copy(f, file)
               }
        }
        
        func postFile(filename string, targetUrl string) error {
            bodyBuf := &bytes.Buffer{}
            bodyWriter := multipart.NewWriter(bodyBuf)
        
            // this step is very important
            fileWriter, err := bodyWriter.CreateFormFile("uploadfile", filename)
            if err != nil {
                fmt.Println("error writing to buffer")
                return err
            }
        
            // open file handle
            fh, err := os.Open(filename)
            if err != nil {
                fmt.Println("error opening file")
                return err
            }
            defer fh.Close()
        
            //iocopy
            _, err = io.Copy(fileWriter, fh)
            if err != nil {
                return err
            }
        
            contentType := bodyWriter.FormDataContentType()
            bodyWriter.Close()
        
            resp, err := http.Post(targetUrl, contentType, bodyBuf)
            if err != nil {
                return err
            }
            defer resp.Body.Close()
            resp_body, err := ioutil.ReadAll(resp.Body)
            if err != nil {
                return err
            }
            fmt.Println(resp.Status)
            fmt.Println(string(resp_body))
            return nil
        }
        
        // sample usage
        func main() {
            target_url := "http://localhost:9090/upload"
            filename := "./astaxie.pdf"
            postFile(filename, target_url)
        }
        ```
        
    - Session & Cookies
        
        ```go
        /*
        	 HTTP, durumsuz olduÄŸundan bilgilerin client ve server arasÄ±nda taÅŸÄ±nabilmesi
        	iÃ§in session ve cookie kullanÄ±lÄ±r.
        	Session, mevcut oturum kapanana kadar isteklerde kullanÄ±lÄ±r.
        	Ancak cookies, ister sÃ¼resiz ya da sÃ¼reli olarak bilgilerin istekler arasÄ±nda
        	taÅŸÄ±nmasÄ±nÄ± saÄŸlar.
        */
        
        // Cookie Set Etme: http.SetCookie(w ResponseWriter, cookie *Cookie)
        expiration := time.Now().Add(365 * 24 * time.Hour)
        cookie := http.Cookie{Name: "username", Value: "astaxie", Expires: expiration}
        http.SetCookie(w, &cookie)
        
        // Cookie Get
        cookie, _ := r.Cookie("username")
        fmt.Fprint(w, cookie)
        
        // alternative to above
        for _, cookie := range r.Cookies() {
        		fmt.Fprint(w, cookie.Name)
        }
        
        /*
        	Session server tarafÄ±nda kaydedilirken cookie daha Ã§ok client tarafÄ± ile
        	ilgilidir. Bu yÃ¼zden cookie'lerde kritik bilgiler tutmak iyi deÄŸildir.
        */
        
        // Bir cookie struct'Ä±nÄ±n iÃ§eriÄŸi
        	type Cookie struct {
          Name       string
          Value      string
          Path       string
          Domain     string
          Expires    time.Time
        	RawExpires string
        
        // MaxAge=0 means no 'Max-Age' attribute specified.
        // MaxAge<0 means delete cookie now, equivalently 'Max-Age: 0'
        	// MaxAge>0 means Max-Age attribute present and given in seconds
        	MaxAge   int
        	Secure   bool
        	HttpOnly bool
        	Raw      string
        	Unparsed []string // Raw text of unparsed attribute-value pairs
        }
        ```
        
        ```go
        /*
        	Session'lar, Cookie'lerin Expire sÃ¼resi 0 olarak ayarlanarak oluÅŸturulur.
        	Client'e bir kez gÃ¶nderilir ve client bunu alÄ±r. Bu bilgi client'Ä±n elinden
        	gidene kadar kullanÄ±labilirdir.
        */
        ```