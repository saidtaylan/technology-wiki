# Docker

- Container'i Ã§alÄ±ÅŸtÄ±rÄ±r. Bulamazsa hub'tan indirir.

```bash
docker run image
```

- Container'i interactive terminal olarak Ã§alÄ±ÅŸtÄ±rÄ±r. Yani ona Ã¶zel bir terminal aÃ§ar. Ã–rneÄŸin ubuntu

```bash
docker run -it image
```

- Interactive terminal olan tty, windowsta Ã§alÄ±ÅŸmadÄ±ÄŸÄ± iÃ§in bir prefix ekliyoruz: â€œwinptyâ€

```bash
winpty docker run -it ubuntu
```

- docker hub'tan(custom da ayarlanabilir) image'yi indirir.

```bash
docker pull image
```

- Ã‡alÄ±ÅŸan containerleri gÃ¶sterir.

```bash
docker ps
```

- Zaman sÄ±ralÄ± olarak Ã§alÄ±ÅŸmÄ±ÅŸ olan continerleri gÃ¶sterir.

```bash
docker ps -a
```

- YÃ¼klÃ¼ imageleri gÃ¶sterir.

```bash
docker images
```

- Gibi ne kadar parametre verirsek verelim, bu satÄ±rÄ± bir setup haline getirir ve "docker start CustomName" dediÄŸimiz zaman o yazdÄ±ÄŸÄ±mÄ±z satÄ±rÄ± Ã§alÄ±ÅŸtÄ±rÄ±r.

```bash
docker run -it --name verilecek_isim ubuntu
```

- Ã‡alÄ±ÅŸan  bir containeri durdurmak iÃ§in

```bash
docker stop ContName || docker stop ContID
```

- Container'ler bir kez Ã§alÄ±ÅŸtÄ±ÄŸÄ± zaman bellekte yer kaplarlar aynÄ± VM'ler gibi silmediÄŸiniz sÃ¼rece. Her ne kadar stop desek de arkaplanda dururlar ama hafÄ±zada yer kaplarlar. Bunu silmek iÃ§in:

```bash
docker rm ContName || docker rm ContID
```

- Image'leri docker'dan kaldÄ±rÄ±r

```bash
docker rmi imageName
```

TAG mantÄ±ÄŸÄ± vardÄ±r. ismiin belirtir. Ã–rneÄŸin uygulamanÄ±n 1,2,3,4 sÃ¼rÃ¼mleri vardÄ±r. Ve biz 5. sÃ¼rÃ¼mÃ¼nÃ¼ indirmek istiyoruzdur. Bunun iÃ§in: 

```bash
docker pull redis:5
```

Tag iki nokta ile belirtilir. Redisi indir. Hangisini, tag'Ä± yani sÃ¼rÃ¼mÃ¼ 5 olanÄ±. BÃ¶ylece bir uygulamanÄ±n birden fazla sÃ¼rÃ¼mÃ¼nÃ¼ sorunsuz kullanabiliriz.

- Ä°smi ubuntu olan image'yi, new-ubuntu isminde bir kopyasÄ±nÄ± oluÅŸturur

```bash
docker image tag ubuntu new-ubuntu
```

- Containeri arkaplanda yani (detach) modda Ã§alÄ±ÅŸtÄ±rmak iÃ§in -d flagini ekliyoruz. Ã§alÄ±ÅŸtÄ±rÄ±nca bize id'sini verir ve terminali serbest bÄ±rakÄ±r.

```bash
docker run -d redis
```

- Detach modda Ã§alÄ±ÅŸan bir containeri tekrardan attach yani (loglarÄ±) gÃ¶rÃ¼nÃ¼r moda getirmek iÃ§in:

```bash
docker attach ContID/ContName
```

- Detach moddaki bir app'i attach moda getirdiÄŸimizde, attach yaptÄ±ÄŸÄ±mÄ±z andan itibaren olan loglarÄ± ekrana basar. Ancak detach moddda iken oluÅŸan loglarÄ± gÃ¶rmek iÃ§in

```bash
docker container logs ContName/ID
```

- EÄŸer bizim , kullanÄ±cÄ± ile iletiÅŸime giren bir terminal uygulamamÄ±z varsa, yani stdin gerektiriyorsa bunun iÃ§in terminal aÃ§mamÄ±z gerekir. EÄŸer direkt

```bash
docker run myapp
```

dersek input alanlarÄ±nÄ± gÃ¶rmezden gelecek ve devam edecektir. 

```bash
docker run -it myapp
```

Bunu engellemek iÃ§in cotaniner'i interaktif terminal flag'i ile aÃ§Ä±yoruz ve terminali yani stdin'i kullanabiliyoruz.

### Port Mapping

Port Mapping iÅŸlemi Ã§ok ama Ã§ok Ã¶nemlidir. Ä°Ã§ ve dÄ±ÅŸ port vardÄ±r. ÅÃ¶yle:

- Ã–rneÄŸin bizim client tarafÄ±ndan mongomuza baÄŸlanmak iÃ§in default olarak 27017 portuna baÄŸlanmamÄ±z gerekir.

```bash
docker run -p 27017:27017 mongo
```

- Ancak docker, kendi iÃ§erisinde uygulamalara ip adresleri ve port'lar atar. Biz run deyip bir uygulamaya baÄŸlanÄ±rken zaten ip adresi ile baÄŸlanmÄ±ÅŸ oluruz aslÄ±nda.

```bash
docker run -p 27017:27017 mongo
```

Birinci 27017 bizim dÄ±ÅŸ portumuz, ikinci 27017 ise iÃ§ portumuz yani docker iÃ§indeki mongonun portudur. -p flag'Ä± port mapping yapacaÄŸÄ±mÄ±zÄ± belirtir. BÃ¶ylece bir kÃ¶prÃ¼ kurmuÅŸ oluruz. DÄ±ÅŸ kaynak portunu yazdÄ±ÄŸÄ±mÄ±zda bizi iÃ§ kaynak portuna aktarmÄ±ÅŸ olur.

### Volume Mapping

Volume mapping de port mapping gibi Ã¶nemlidir. Bir container Ã§alÄ±ÅŸmayÄ± durdurduÄŸunda iÃ§indeki verileri siler. Yani docker container stateless'tÄ±r. Bu yÃ¼zden db verilerini container'da saklayamayÄ±z.

Bu yÃ¼zden db'nin verilerini kaydettiÄŸi klasÃ¶r ile bilgisayarÄ±mÄ±zdaki istediÄŸimiz bir kalsÃ¶rÃ¼ eÅŸleÅŸtiriyoruz. DB'ye bir veri yazÄ±ldÄ±ÄŸÄ±nda bizim seÃ§tiÄŸimiz klasÃ¶re yazÄ±lÄ±yor.
AÅŸaÄŸÄ±dakinin sonucunda mongonun db'sine yazÄ±lan veriler benim-klasor'e yazÄ±lacak

```bash
docker run -p 27017:27017 -v /home/benim-klasor:/data/db mongo 

```

---

- Container ile ilgili geniÅŸ bilgileri json formatÄ±nda verir. Neredeyse her bilgiyi.

```bash
docker inspect ContName/ID
```

### Ã‡evre deÄŸiÅŸkenleri

Stdin'de eÄŸer Ã§evre deÄŸiÅŸkeni girmek istersek bunu -e flag'i ile belirtiyoruz. Ã–rneÄŸin mysql yÃ¼klediskten sonra buna terminal Ã¼zerinden bir ÅŸifre girmek zorunayÄ±z: 

```bash
docker run -e MYSQL_ROOT_PASSWORD=my_secret_password mysql
```

### Container iletiÅŸimi

[https://www.tutorialworks.com/container-networking/#:~:text=For containers to communicate with,use to address each other](https://www.tutorialworks.com/container-networking/#:~:text=For%20containers%20to%20communicate%20with,use%20to%20address%20each%20other)

- NodeJS ile yapÄ±lmÄ±ÅŸ bir TODO uygulamamÄ±z olsun. Bu uygulamada 127.0.0.1:8000'e istek atÄ±yor olalÄ±m Ancak Docker, her container'i sÃ¼rekli aynÄ± ip adresinde Ã§alÄ±ÅŸtÄ±racaÄŸÄ± garantisini vermez. Bu yÃ¼zden diÄŸer container'lerle iletiÅŸim kurmak iÃ§in onlarÄ±n adlarÄ±nÄ± kullanabilir. Bunun iÃ§in container'leri oluÅŸtururken ad vermek Ã¶nemlidir.
- Container'leri birbirileriyle aÄŸ Ã¼zerinden konuÅŸur. En kolayÄ± bridge network'tÃ¼r. Docker, baÅŸladÄ±ÄŸÄ±nda bir default bridge oluÅŸturur. BÃ¼tÃ¼n container'ler default olarak buraya baÄŸlanabilir. AynÄ± aÄŸda olduklarÄ± iÃ§in birbirleriyle konuÅŸabilirler. Ama bu her zaman istenen bir ÅŸey deÄŸildir.
Bir ÅŸekilde izole etmeliyiz. Bu yÃ¼zden custom network'ler kullanÄ±yoruz. Yeni network'ler oluÅŸturuyoruz ve iliÅŸkili olan container'leri bu networke baÄŸlyoruz. Ä°zole olarak bir odadaymÄ±ÅŸ gibi sohbet edebiliyorlar.

```bash
docker network create --driver bridge my-custom-network 
```

- Mevcut bir docker ÅŸu ÅŸekilde listelenebilir ve silinebilir:

```bash
docker network ls|list
docker network rm my-custom-network 
```

- Docker'in, iÃ§indeki containerlerin iletiÅŸebilmesi iÃ§in aÄŸ tÃ¼rleri vardÄ±r:
    - Bridge: Default olarak gelen kÃ¶prÃ¼ tÃ¼rÃ¼dÃ¼r. Komut satÄ±rÄ±na herhangi bir ÅŸey yazmaya gerek yoktur.
    - None: Bir containere dÄ±ÅŸarÄ±dan baÅŸka bir container'in eriÅŸmesini engeller. ArtÄ±k kimse ile iletiÅŸim kuramaz.
    (--network=none)
    â™¦ Host: Container'ler birbiri ile kÃ¶prÃ¼deki gibi direk iletiÅŸim kurmaz da docker host Ã¼zerinden iletiÅŸim kurar. Ä°steÄŸi host'a atar. O da diÄŸer container ile iletiÅŸim kurar.                    (--network=host)
    - Custom networkler de oluÅŸturabiliriz. Docker'in default gelen gatewayini deÄŸiÅŸtirebiliriz Ã¶rneÄŸin.
    AdÄ± name-of-my-custom-network olan, tipi brdige olan, 182.18.0.1 gatewayini kullanan bir network oluÅŸturur

```bash
docker network create --driver bridge --subnet 182.18.0.0/16 --gateway 182.18.0.1 name-of-my-custom-network
```

```
	â€¢ docker run --net name-of-my-custom-network -d mongo => mongo arkaplanda benim
    belirlediÄŸim aÄŸ Ã¼zerinde Ã§alÄ±ÅŸacak.

	â€¢ docker network ls => var olan aÄŸlarÄ± listeler.

	â€¢ docker network rm any-network => mevcut bir aÄŸÄ± siler

	â€¢ docker inspect networkName => network detaylarÄ±nÄ± verir

```

- Ä°ki uygulamaÄ± birbirine baÄŸlamak iÃ§in aynÄ± aÄŸ altÄ±nda olmalarÄ± gerekir. AÅŸaÄŸÄ±daki Ã¶rnekte ikisi de my-custom-network altÄ±nda bulunduklarÄ± iÃ§in birbirlerinin ip adreslerine ihtiyaÃ§larÄ± olmadan sadece isimleri ile bile eriÅŸebilirler.
Ä°lk olarak mongoyu Ã§alÄ±ÅŸtÄ±rdÄ±k ama burada port bindinge gerekyok Ã§Ã¼nkÃ¼ dÄ±ÅŸ dÃ¼nyadan zaten eriÅŸmeyeceÄŸiz. Sadece aÄŸ iÃ§indeki diÄŸer uygulamalardan eriÅŸeceÄŸiz. 
NodeJS uygulamamÄ±zda Mongo URIâ€™sine baÄŸlanmak iÃ§in, nasÄ±l [localhost](http://localhost) yazÄ±yorsak onun yerine bu sefer mongo containerâ€™inin ismini yazdÄ±k. Ama nodejs uygulamasÄ±na port binding yaptÄ±k Ã§Ã¼nkÃ¼ bu uygulama zaten dÄ±ÅŸ dÃ¼nyadan eriÅŸilmek iÃ§ni tasarlandÄ± ğŸ˜€

```bash
docker run --name mongo-server --net my-custom-network mongo
docker run --name my-nodejs-app --net my-custom-network -p 3000:3000 nodejs-app

// Nodejs mongo connect uri
mongo.connect("http://mongo-server:27017")
```

- Bir containerâ€™i, belirli bir aÄŸda Ã§alÄ±ÅŸtÄ±rmak iÃ§in:

```bash
docker run --name mongo-server --net my-custom-network mongo
```

## Docker File

### Environment Variables

```docker
ENV db_host=localhost:27017
```

### WORKDIR

Docker linux image iÃ§indeki Ã§alÄ±ÅŸma dizinini set eder. EÄŸer Ã¶yle bir klasÃ¶r yoksa oluÅŸturur.

```docker
WORKDIR /node-app
```

### COPY

Docker file iÃ§inde bulunan klasÃ¶rden linux image iÃ§indeki klasÃ¶re dosya/klasÃ¶r kopyalar.

```docker
COPY . /node-app/
```

### ADD

Docker file iÃ§inde bulunan klasÃ¶rden linux image iÃ§indeki klasÃ¶re dosya/klasÃ¶r kopyalar. Ancak biraz daha karmaÅŸÄ±ktÄ±r. Ancak lokalden hedefe dosya aktarÄ±rken COPY komutu tercih edilir. 

```docker
ADD . .
```

### Dockerignore

Build alÄ±nÄ±rken, belli klasÃ¶r ya da dosyalarÄ±n buna dahil olmamasÄ±nÄ± saÄŸlar. Gitignore gibi Ã§alÄ±ÅŸÄ±r. Ã–rneÄŸin â€œnode_modules klasÃ¶rÃ¼nÃ¼ build alÄ±nÄ±rken WORKDIRâ€™e kopyalamaâ€ diyoruz.. Biz zaten node_modulesâ€™i 

```bash
npm install
```

yaparak Ã¼reteceÄŸiz container iÃ§inde

### EXPOSE

Dockerize edilecek uygulamanÄ±n hangi port Ã¼zerinden serve edileceÄŸini bildirir. Expose aslÄ±nda bir ÅŸey yapmaz. Sadece dockerfile dosyasÄ±nÄ± okuyan kiÅŸiye bu uygulamanÄ±n hangi porttan Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ± bildirir. Yoksa EXPOSE komutu olmasa da uygulama o porttan Ã§alÄ±ÅŸacaktÄ±r. Portun yanÄ±na isteÄŸe baÄŸlÄ± olarak udp veya tcp olarak protokol de belirtilebilir. Default olarak TCPâ€™dir.

```docker
EXPOSE 3000/tcp
```

### CMD

UygulamanÄ±n run edileceÄŸi komuttur. Liste, argÃ¼man olarak baÅŸka Ã¶geler alabilir.

```bash
CMD ["node", "app.js", "arg1", "arg2"] || CMD node app.js arg1 arg2
```

CMD, overwritable bir komuttur. Yani biz uygulamayÄ± Ã§alÄ±ÅŸtÄ±rÄ±rken image isminin saÄŸÄ±na bazÄ± komutlar yazarsak, bu komutlar CMDâ€™nin Ã¼zerine yazÄ±lacak ve saÄŸdaki komutlar geÃ§erli olacaktÄ±r

```bash
CMD node app.js 3000

docker run mongo node app.js 4000
```

EÄŸer bu ÅŸekilde bir ÅŸey yapÄ±lÄ±rsa uygulama 3000 portundan Ã§alÄ±ÅŸmaya ayarlÄ± olmasÄ±na raÄŸmen daha sonra Ã§alÄ±ÅŸtÄ±rma esnasÄ±nda 4000â€™e ayarlanÄ±r.

### ENTRYPOINT

CMDâ€™ye benzer ÅŸekilde bir dosyayÄ± Ã§alÄ±ÅŸtÄ±rÄ±r. CMDâ€™nin askine overwritable deÄŸildir. Bir Ã§alÄ±ÅŸtÄ±rÄ±labilir dosya alÄ±p argÃ¼manlarÄ±(argÃ¼man gÃ¶ndermek zorunludur) kullanÄ±cÄ±dan ister. 

```bash
ENTRYPOINT ["node"]

docker run my-app app.js
```

Node uygulamasÄ±nÄ± Ã§alÄ±ÅŸtÄ±racak ama argÃ¼man olarak app.js aldÄ±ÄŸÄ± iÃ§in app.jsâ€™i Ã§alÄ±ÅŸtÄ±racak.

## SPA UygulamalarÄ±nÄ± Dockerize Etmek

Elbette bir Vue uygulamasÄ±nÄ± yayÄ±nlamadan Ã¶nce build almak gerekir. Bunun iÃ§in build alÄ±yoruz ve live-server ile dist klasÃ¶rÃ¼nÃ¼ yani build alÄ±nmÄ±ÅŸ klasÃ¶rÃ¼ yayÄ±nlÄ±yoruz. Peki neden live-server kullanÄ±yoruz? Ã‡Ã¼nkÃ¼ biz NGINX ya da apache gibi real bir sunucu kullanmÄ±yoruz. Onlar olmadan da bu iÃ§eriÄŸi sunabilmek iÃ§in live-server kullanÄ±yoruz.

Development esnasÄ±nda peki neden live-serverâ€™a gerek yoktu. Ã‡Ã¼nkÃ¼ vue environment dahili olarak bize bir server saÄŸlÄ±yordu. 

Ama biz artÄ±k build aldÄ±k ve ÅŸuan elimizde olan ÅŸey sadece birkaÃ§ js, html, css, imgâ€¦ dosyalarÄ±. Bunu sunabilmek iÃ§in bir live-serverâ€™a ihtiyacÄ±mÄ±z var.

```docker
FROM node:lts-alpine

# install simple http server for serving static content
RUN npm install -g live-server

# make the 'app' folder the current working directory
WORKDIR /app

# copy both 'package.json' and 'package-lock.json' (if available)
COPY package*.json ./

# install project dependencies
RUN npm install

# copy project files and folders to the current working directory (i.e. 'app' folder)
COPY . .

# build app for production with minification
RUN npm run build

EXPOSE 8080
CMD [ "http-server", "dist" ]
```

---

Ancak nginx gibi reel bir ortama geÃ§tiÄŸimizde elbette live-serverâ€™a ihitiyaÃ§ kalmÄ±yor. 

```docker
# build stage
FROM node:lts-alpine as build-stage
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
RUN npm run build

# production stage
FROM nginx:stable-alpine as production-stage
COPY --from=build-stage /app/dist /usr/share/nginx/html
EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]
```

## Docker Prune

Ã‡alÄ±ÅŸmayan yani stop olmuÅŸ bÃ¼tÃ¼n containerâ€™leri siler. 
BÃ¼tÃ¼n imageâ€™leri siler.

```bash
docker container prune
docker image prune
```

# Docker Compose

UzantÄ±sÄ± docker-compose.ymlâ€™dir.

### Version

Docker, docker-compose dosyalarÄ± iÃ§in gÃ¼ncellemeler getirir. Ama biz uygulamayÄ± yaptÄ±ÄŸÄ±mÄ±zda versiyon adÄ±nÄ± yazÄ±yoruz ki yeni gelen gÃ¼ncellemeler bizim dosyamÄ±zÄ± etkilemesin. Ã‡Ã¼nkÃ¼ yeni gelen gÃ¼ncellemeyle beki de syntaxâ€™Ä± deÄŸiÅŸir

```docker
version : "3.4"
```

### Services

UygulamanÄ±n baÄŸlÄ± olduÄŸu(postgres, redis, rabbitmq), uygulamanÄ±n ana Ã§ekirdeÄŸi(app.js) dahil bÃ¼tÃ¼n servisler buranÄ±n altÄ±na yazÄ±lÄ±r.

### Build docker file

Ä°lla ki mevcut uygulamamÄ±zÄ± build ettikten sonra servislerin iÃ§ine koymak zorunda deÄŸiliz. Bir servis olarak docker file yolunu gÃ¶sterirseniz bizim iÃ§in kendisi build olacaktÄ±r.

```docker
version: "3.4"
services:
	node-server:
		build: . // Ã§Ã¼nkÃ¼ docker file, compose ile aynÄ± konumda
		ports:
			- 3001:3000 // iÃ§ port 3000, dÄ±ÅŸ port 3001 olacak.
```

### Run/Build docker compose

```bash
docker-compose up
```

dendiÄŸinde docker-compose dosyasÄ± build edilip Ã§alÄ±ÅŸtÄ±rÄ±lÄ±r

```bash
docker compose build
```

dendiÄŸinde docker-compose dosyasÄ± sadece build edilir.

### Container Name

Containerâ€™lere isim verilmezse klasÃ¶r ismi ve servis isminin birleÅŸiminden uzun bir isim oluÅŸacak. Bunun Ã¶nÃ¼ne geÃ§mek iÃ§in servislere custom isim verebiliyoruz.

```bash
version: "3.4"
services:
	node-server:
		container_name: my-server
		build: .
		ports:
			- 3001:3000
```

### Down

Ã‡alÄ±ÅŸan containerâ€™i kapatÄ±r.

```bash
docker-compose down
```

## Tam bir Ã¶rnek

```docker
version: "3.4"
services:
  todo-app:
    container_name: dc-todo-app
    build: .
    ports:
      - 3000:3000

// kod iÃ§inde mongo'ya eriÅŸilmek istendiÄŸinde servis ismi kullanÄ±lÄ±r.
  mongodb:
    image: mongo
    ports:
      - 27017:27017

		// mongo iÃ§in volume mapping
    volumes:
      - todo-app-data:/data/db

// mapping yapÄ±lan local cihazdaki volume'ler bu ÅŸekilde yazÄ±lÄ±r.
volumes:
  todo-app-data:
```

### Volumes by File Uploads

```docker
version: "3.4"
services:
  uploader-app:
    build: .
    ports:
      - 3000:3000
    volumes:
				// uygulama iÃ§inde /uploads klasÃ¶rÃ¼ne yÃ¼klenen dosyalar artÄ±k local cihazÄ±n 
				// uploader-app-uploads klasÃ¶rÃ¼ne gidecek.
      - uploader-app-uploads:/uploads
volumes:
  uploader-app-uploads:
```

### Wordpress Example

```docker
version: "3.4"
services:
  wordpress:
    image: wordpress
    ports:
      - 8080:80
    environment:
      WORDPRESS_DB_HOST: db
      WORDPRESS_DB_USER: bloguser
      WORDPRESS_DB_PASSWORD: test123
      WORDPRESS_DB_NAME: blogdb
    volumes:
      - wordpress:/var/www/html
  db:
    image: mysql:5.7

		// servis bir ÅŸekilde durduÄŸunda tekrardan baÅŸlar.
    restart: always
    environment:
      MYSQL_DATABASE: blogdb
      MYSQL_USER: bloguser
      MYSQL_PASSWORD: test123
      MYSQL_RANDOM_ROOT_PASSWORD: "1"
    volumes:
      - db:/var/lib/mysql
volumes:
  wordpress:
  db:
```

### Depends on

Bizim servisimiz baÅŸka bir servisin baÅŸlamasÄ±na baÄŸlÄ±ysa, baÄŸlÄ± olan servisi belirtiriz. Mesela uygulamamÄ±z Redis olmadan Ã§alÄ±ÅŸamÄ±yorsa uygulama Depends on ile baÄŸlanÄ±r.

```docker
services:
	twitter:
		depends_on:
			- redis
			- mongo
	redis:
	mongo:
```

### Docker file and environment Variable

Docker file iÃ§inde uygulama envâ€™leri belirtilmiÅŸse bunlar ayrÄ±ca docker compose iÃ§inde de belirtilmelidir.