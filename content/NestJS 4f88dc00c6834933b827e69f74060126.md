# NestJS

### Controller

```tsx
import {
  Body,
  Controller,
  Get,
  HostParam,
  HttpCode,
  Param,
  Paramtype,
  Post,
  Query,
  Req,
  Res,
} from '@nestjs/common';
import { Request, Response } from 'express';

// Interface yerine class Ã¶neriliyor. Ã‡Ã¼nkÃ¼ saf JS'te interface diye
// bir ÅŸey yok. Bu yÃ¼zden Nest runtime'da bu tipi bulamaz.
// DTO, istemciden gelen isteÄŸin ÅŸablonunu belirtir. **Data Transfer Object** 
// Pipe, runtime'da Ã§alÄ±ÅŸan bir ÅŸeydir ve bu yÃ¼zden interface'yi gÃ¶rmeyebilir.
export class CreateCatDto {
  name: string;
  age: number;
  breed: string;
}

@Controller('cats')
export class CatsController {
  @Get('cat/:id')
  //@HttpCode(200)
  findAll(@Req() request: Request, @Param("id") id:string, @Res response: Response)
	: any {
    return `id of this cat is ${id}`
  }
  findAll(@Req() request: Request, @Param("id") id:string ): any {
    return `id of this cat is ${id}`
  }
  findAll(@Req() request: Request, @Param() params): string {
    return `id of this cat is ${params.id}`;
  }

  // EÄŸer metodun iÃ§erisinde await kullanÄ±lmayacaksa metodu
  // async olarak oluÅŸturmanÄ±n bir manasÄ± yok.
  @Post('new')
  async create(@Body() newCat: CreateCatDto, @Res() res: Response) {
    res.send(`${newCat.name}, ${newCat.age}, ${newCat.breed}`);
  }

  @Get()
  async stuff(): Promise<any[]> {
    return [];
  }

  // Sorguya yazÄ±lan query parametrelerini obje ÅŸeklinde
  // @Query() ile alabiliriz
  @Get("query-im")
  queryMethod(@Query() query) {
    return `This action returns all cats (limit: ${JSON.stringify(query)} items)`;
  }

			// Ã–zel adreslere controller'lar oluÅŸturulabilir.
	@Controller({ host: 'admin.example.com' })
	export class AdminController {
	  @Get()
	  index(): string {
	    return 'Admin page';
	  }
	}
	
	// HostParam, Subdomain'i verir.
	@Controller({host: 'account.example.com'})
	export class AccountController {
	  @Get()
	  getInfo(@HostParam('account') account: string) {
	    return account;
	  }
	}
}

```

### Provider / Service

```tsx
// Servis, controller'e metod saÄŸlayan **saÄŸlayÄ±cÄ±dÄ±r.
// Servis iÃ§inde oluÅŸturulan metotlar controller iÃ§inde kullanÄ±lÄ±r.

// cats.interface.ts
export interface Cat {
  name: string;
  age: number;
  breed: string;
}

// cats.service.ts
import { Injectable } from '@nestjs/common';
import { Cat } from './interfaces/cat.interface';

@Injectable()
export class CatsService {
  private readonly cats: Cat[] = [];

  create(cat: Cat) {
    this.cats.push(cat);
  }

  findAll(): Cat[] {
    return this.cats;
  }
}

// cats.controller.ts
import { Controller, Get, Post, Body } from '@nestjs/common';
import { CreateCatDto } from './dto/create-cat.dto';
import { CatsService } from './cats.service';
import { Cat } from './interfaces/cat.interface';

@Controller('cats')
export class CatsController {
// Bir diÄŸer Ã¶nemli husus ise Dependency injection'dÄ±r.
// Yani Nest'te controller'in Service'e baÄŸÄ±mlÄ± olmasÄ±.
// AÅŸaÄŸÄ±daki contructor ile de Service, controller'a enjekte edilmiÅŸtir.
  constructor(private catsService: CatsService) {}

  @Post()
  async create(@Body() createCatDto: CreateCatDto) {
    this.catsService.create(createCatDto);
  }

  @Get()
  async findAll(): Promise<Cat[]> {
    return this.catsService.findAll();
  }
}**
```

### Module

<aside>
ğŸ’¡ ModÃ¼ller, servis ve kontrolÃ¶rleri birleÅŸtiren bir dosya.
AslÄ±nda uygulamamÄ±zÄ±n iÃ§indeki ilgili servis ve kontrolÃ¶rleri organize ederek daha esnek ve okunabilir bir sistem saÄŸlÄ±yor.
BÃ¼yÃ¼k bir uygulama da birÃ§ok farklÄ± sistem olabilir.
Ã–rneÄŸi; user, cart, account...
Her bir servis kendi iÃ§inde bir yapÄ±dÄ±r. Her servis baÅŸlÄ± baÅŸÄ±na bir klasÃ¶rdÃ¼r ve kendi iÃ§erisinde service, controller ve module barÄ±ndÄ±rÄ±r.

</aside>

```tsx
// UygulamamÄ±z, birden Ã§ok kÃ¼Ã§Ã¼k modÃ¼lden oluÅŸabilir demiÅŸtik.
// Bu yÃ¼zden bÃ¼tÃ¼n modÃ¼lleri bir ana modÃ¼lde toplamamÄ±z gerekiyor.
// Åuan tam olarak bunu yapÄ±yoruz.

// app.module.ts
import { Module } from '@nestjs/common';
import { CatsModule } from './cats/cats.module';

@Module({
  imports: [CatsModule],
})
export class AppModule {}

// cats.module.ts
import { Module } from '@nestjs/common';
import { CatsController } from './cats.controller';
import { CatsService } from './cats.service';

@Module({
  controllers: [CatsController],
  providers: [CatsService],
})
export class CatsModule {}
```

```tsx
/*
Default olarak her module singleton yani baÄŸÄ±msÄ±zdÄ±r. Bu yÃ¼zden modÃ¼ller rahatlÄ±kla
paylaÅŸÄ±labilir. PaylaÅŸÄ±lmak istenen modÃ¼l export edilir. Ve diÄŸer modÃ¼ller bunu
import edebilir.
*/

import { Module } from '@nestjs/common';
import { CatsController } from './cats.controller';
import { CatsService } from './cats.service';

@Module({
  controllers: [CatsController],
  providers: [CatsService],
  exports: [CatsService]
})
export class CatsModule {}
```

```tsx
// import edilmiÅŸ modÃ¼ller aynÄ± anda export da edilebilir.

@Module({
  imports: [CommonModule],
  exports: [CommonModule],
})
export class CoreModule {}
```

```tsx
// Her modÃ¼lÃ¼ gereken dosyalarda import etmek gerekir. Ancak bir modÃ¼l
// birÃ§ok modÃ¼lde kullanÄ±lÄ±yorsa modÃ¼lÃ¼ global hale getirebiliriz.
// ArtÄ±k o modÃ¼lÃ¼ import etmeden kullanabiliriz

import { Module, Global } from '@nestjs/common';
import { CatsController } from './cats.controller';
import { CatsService } from './cats.service';

@Global()
@Module({
  controllers: [CatsController],
  providers: [CatsService],
  exports: [CatsService],
})
export class CatsModule {}

// UnutulmamlÄ±dÄ±r ki her ÅŸeyin Global yapÄ±lmasÄ± iyi bir ÅŸey deÄŸildir.
```

### Middleware

```tsx
// Default olarak Express'in middlewaresi kullanÄ±lÄ±r.

// logger.middlewares.ts
import { Injectable, NestMiddleware } from '@nestjs/common';
import { Request, Response, NextFunction } from 'express';

@Injectable()
export class LoggerMiddleware implements NestMiddleware {
  use(req: Request, res: Response, next: NextFunction) {
	// for fastify (node pure request and response)
	use(req: IncomingMessage , res: ServerResponse, next)
    console.log('Request...');
    next();
  }
}

// logger.module.ts
import { Module, NestModule, MiddlewareConsumer } from '@nestjs/common';
import { LoggerMiddleware } from './common/middleware/logger.middleware';
import { CatsModule } from './cats/cats.module';

@Module({
  imports: [CatsModule],
})
export class AppModule implements NestModule {
  configure(consumer: MiddlewareConsumer) {
    consumer
      .apply(LoggerMiddleware)
      .forRoutes('cats');
  }
}

// AyrÄ±ca route'lara gelecek isteklere gÃ¶re de sÄ±nÄ±rlayabiliriz.
@Module({
  imports: [CatsModule],
})
export class AppModule implements NestModule {
  configure(consumer: MiddlewareConsumer) {
    consumer
      .apply(LoggerMiddleware)
      .forRoutes({path: 'cats', method: RequestMethod.GET});
  }
}

// forRoutes, middleware'nin hangi path'lere uygulanacaÄŸÄ±nÄ± belirler.
// AyrÄ±ca direkt olarak bir controller da alabilir.
import { Module, NestModule, MiddlewareConsumer } from '@nestjs/common';
import { LoggerMiddleware } from './common/middleware/logger.middleware';
import { CatsModule } from './cats/cats.module';
import { CatsController } from './cats/cats.controller';

@Module({
  imports: [CatsModule],
})
export class AppModule implements NestModule {
  configure(consumer: MiddlewareConsumer) {
    consumer
      .apply(LoggerMiddleware)
      .forRoutes(CatsController);
  }
}

// Middleware'yi bir controller'in tamamÄ±na uygulamak istemeyebiliriz.
consumer
  .apply(LoggerMiddleware)
  .exclude(
    { path: 'cats', method: RequestMethod.GET },
    { path: 'cats', method: RequestMethod.POST },
    'cats/(.*)',
  )
  .forRoutes(CatsController);
```

```tsx
// Middleware'yi class olarak tanÄ±mlamak zorunda deÄŸiliz.
// Basit bir fonksiyon ÅŸeklinde de tanÄ±mlayabiliriz.
import { Request, Response, NextFunction } from 'express';

export function logger(req: Request, res: Response, next: NextFunction) {
  console.log(`Request...`);
  next();
};

// app.module.ts
consumer
  .apply(logger)
  .forRoutes(CatsController);
```

```tsx
// Ã‡oklu middleware'ler tanÄ±mlayabiliriz
consumer.apply(cors(), helmet(), logger).forRoutes(CatsController);
```

```tsx
// Global middleware

const app = await NestFactory.create(AppModule);
app.use(logger);
await app.listen(3000);

// Global middleware iÃ§inde dependency enjection kullanÄ±lamaz.
```

### Exception Filter

```tsx
// Nest, hata yakalama sistemi sunar. Bir yerde cevap olarak istemciye hata dÃ¶ndÃ¼rÃ¼lmesi
// iÃ§in metot saÄŸlar.

@Get()
async findAll() {
  throw new HttpException('Forbidden', HttpStatus.FORBIDDEN);
}

// Bu iÅŸlem istemcide ÅŸu ÅŸekilde gÃ¶rÃ¼nÃ¼r:
/*
{
  "statusCode": 403,
  "message": "Forbidden"
}
*/
```

```tsx
// Custom exceptions

export class ForbiddenException extends HttpException {
  constructor() {
    super('Forbidden', HttpStatus.FORBIDDEN);
  }
}

@Get()
async findAll() {
  throw new ForbiddenException();
}
```

```tsx
// Filter decorator

@Post()
@UseFilters(new HttpExceptionFilter())
async create(@Body() createCatDto: CreateCatDto) {
  throw new ForbiddenException();
}
```

```tsx
// Global exception filter

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  app.useGlobalFilters(new HttpExceptionFilter());
  await app.listen(3000);
}
bootstrap();
```

### Pipes

```tsx
// AtÄ±lan iste controller'Ä±n ilgili metoduna ulaÅŸmadan hemen Ã¶nce araya girerek
// parametre ve sorgular, body ve custom diÄŸer ÅŸeyler Ã¼zerinde doÄŸrulama ve benzeri
// iÅŸlemler yapmayÄ± saÄŸlar.
// Bir nevi middleware gibi dÃ¼ÅŸÃ¼nÃ¼lebilir. Ancak middleware, daha gelen isteÄŸin
// hangi path'e gideceÄŸinin belirlenmesinden Ã¶nce Ã§alÄ±ÅŸÄ±r.
// Nest'te dahili olarak gelen pipe tÃ¼rleri: ParseIntPipe: isminden de anlaÅŸÄ±lacaÄŸÄ±
// Ã¼zere gelen parametre ya da query, int mi diye bakar. DeÄŸilse geriye response
// olarak bir json dÃ¶ner.

/*
ValidationPipe
ParseIntPipe
ParseFloatPipe
ParseBoolPipe
ParseArrayPipe
ParseUUIDPipe
ParseEnumPipe
DefaultValuePipe
*/

@Get(':id')
async findOne(@Param('id', ParseIntPipe) id: number) {
  return this.catsService.findOne(id);
}
// EÄŸer atÄ±lan isteketeki 'id' parametresi int deÄŸilse geriye aÅŸaÄŸÄ±daki gibi bir
// cevap dÃ¶ner.

{
  "statusCode": 400,
  "message": "Validation failed (numeric string is expected)",
  "error": "Bad Request"
}

// Ancak bu JSON objesi de Ã¶zelleÅŸtirilebilir:
@Get(':id')
async findOne(
  @Param('id', new ParseIntPipe({ errorHttpStatusCode: HttpStatus.NOT_ACCEPTABLE }))
  id: number,
) {
  return this.catsService.findOne(id);
}

// Bu iÅŸlemler query parametreleri iÃ§in de geÃ§erlidir.
@Get()
async findOne(@Query('id', ParseIntPipe) id: number) {
  return this.catsService.findOne(id);
}
```

```tsx
// Custom Pipe

import { PipeTransform, Injectable, ArgumentMetadata } from '@nestjs/common';

@Injectable()
export class ValidationPipe implements PipeTransform {
  transform(value: any, metadata: ArgumentMetadata) {
    return value;
  }
}

// value: pipe'e gelen parametre deÄŸeridir.
// metadata ise ÅŸunlardan oluÅŸur:
/*
export interface ArgumentMetadata {
  type: 'body' | 'query' | 'param' | 'custom';
  metatype?: Type<unknown>;
  data?: string;
}
*/

// Nest ile Joi kullanÄ±mÄ±na bak
```